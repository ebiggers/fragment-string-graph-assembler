\documentclass[10pt]{article}
\usepackage[left=3.3cm,right=3.3cm,bottom=3.0cm,top=3.0cm]{geometry}
\usepackage{float}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{subcaption}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{comment}
%\usepackage{amsthm}

\usetikzlibrary{arrows}

%\floatstyle{boxed}
%\restylefloat{figure}

%\theoremstyle{definition}
%\newtheorem{definition}{Definition}

\newcommand{\LengthVar}{L}
\newcommand\Base[1]{{\tt #1}}
\newcommand{\ReadArrowType}{latex}
\newcommand{\Figure}[1]{Figure \ref{#1}}

\title{A Bidirected String Graph Model for Genome Assembly}
\author{Eric Biggers}

\begin{document}
\maketitle

%\begin{abstract}
%Sequencing an organism's genome is an important step to further genetic research
%on that organism.  However, current sequencing machines can only sequence very
%short fragments of DNA that originate from random positions on the original
%genome, assembly software such as Allpaths-LG can be used to assemble these
%fragments into longer contiguous sequences.  
%\end{abstract}

\section{Introduction to genome sequencing and assembly}

\subsection{Definition of a genome}

Every living organism contains a collection of hereditary material called a {\em
genome}.  Typically, each cell of a multicellular organism contains a complete
copy of that organism's genome.  A genome consists of one or more DNA ({\it
deoxyribonucleic acid}) molecules in the form of {\it chromosomes}.  DNA is a
double-stranded molecule, each strand of which is a polymer of {\em
nucleotides}.  A nucleotide, together with the corresponding nucleotide on the
opposite strand, is called a {\it base pair} (abbreviation: {\it bp}).  In DNA,
there are four possible nucleotides: adenine, cytosine, guanine, and thymine,
which are abbreviated as \Base{A}, \Base{C}, \Base{G}, and \Base{T},
respectively.  \Base{A} always pairs with T on the other strand, and \Base{C}
always pairs with \Base{G} on the other strand.  In addition, each strand has a
direction, and the two strands of a DNA molecule are directed opposite one
another.  Furthermore, a DNA molecule may be circular, as is usually the case
for bacterial chromosomes.

Based on these biological facts, a genome is formally defined, for the purposes
of this paper, as a set of possibly circular, dual-stranded strings of the
symbols \Base{A}, \Base{C}, \Base{G}, and \Base{T}, where dual-stranded has the
meaning indicated above: the two strands run in opposite directions, and the
pairings \Base{A}---\Base{T} and \Base{C}---\Base{G} always hold.

This definition does not account for the fact that the genomes of diploid and
polyploid organisms, including most plants and animals, contain multiple
slightly-differing copies of each chromosome.  In this case, the above
definition will consider each copy of each chromosome to be a completely
different string in the genome, unless the copies are completely identical.

Genomes vary widely in size, from several thousand base pairs to many billion
base pairs, depending on the organism (see Table \ref{tab:GenomeSizes}).

\begin{table}[H]
	\begin{center}
		\begin{tabular}{|l|p{4.5cm}|}
			%\hline
			%$\phi$X174 bacteriophage &  $\sim$5,000 bp \\
			%\hline
			%Human mitochondrion &  $\sim$16,000 bp \\
			\hline
			{\bf Organism} & {\bf Approximate genome size (in base
			pairs)} \\
			\hline
			{\it Variola} virus (smallpox) &  186,000 \\
			\hline
			{\it E. coli} (a bacterium) & 4,600,000 \\
			\hline
			{\it Ananas comosus} (domesticated pineapple) & 500,000,000 \\
			\hline
			{\it Zea mays} (domesticated corn) & 2,000,000,000 \\
			\hline
			{\it Homo sapiens} (human)       &  3,200,000,000 \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Approximate genome sizes of selected organisms}
	\label{tab:GenomeSizes}
\end{table}

\subsection{Genome sequencing}

{\it DNA sequencing} is the process of determining the base pair sequence of
({\it sequencing}) one or more DNA molecules.  {\it Genome sequencing} is the use
of DNA sequencing to determine the base pair sequence of an entire genome.

Sequencing a DNA molecule is very difficult because it is in fact an actual
molecule, which makes each base pair much too small to be directly observed.
Therefore, indirect laboratory techniques must be used.  Advances in these
techniques are progressing rapidly, and they can now be performed by automated
machines.  However, every technique suffers from the limitation that only short
fragments of DNA several dozen to several thousand base pairs long can be
sequenced.

Therefore, to sequence an entire genome, which may be millions of
base pairs long, the DNA from the genome must be broken into much smaller
fragments, which are then sequenced.  Following this, the original genome is
computationally reconstructed by a computer program called a {\it genome
assembler} in a process called {\it genome assembly}.  {\it Genome sequencing}
therefore refers to the entire process of sequencing a genome, including both
lab work and computational work, while {\it genome assembly} only refers to the
computational work.\footnote{It usually also takes some technology-specific
computational work to actually prepare the sequences for assembly; for example,
a series of digital photographs of clumps of fluorescently labeled molecules
might need to be interpreted as reads using image-processing algorithms.
However, these programs and/or algorithms generally have already been developed
by the manufacturer of the sequencing machine and work fairly well, and ``genome
assembly'' does not cover these algorithms, although genome assembly algorithms
still may be tuned for specific sequencing technologies.}

\subsection{Genome assembly}

\label{subsec:reads}

The goal of genome assembly is to reconstruct a genome, as defined earlier,
given a set of substrings that may originate from any strand of any DNA molecule
in the genome.  Each substring is called a {\it read} and is the sequence of
some DNA that was sequenced by the sequencing machine.  In general, reads may
contain errors, including {\it substitutions}, where a base pair in the read was
incorrectly read as some other base pair, as well as {\it insertions}, where a
sequence of one or more random base pairs have been inserted into some position
in the read, and {\it deletions}, where a sequence of one or more base pairs
from the original genome is missing from the interior of the read.  Reads are
expected to be uniformly distributed on the genome with a certain coverage $X$
depending on how much data was collected, meaning that each base pair in the
original genome is expected to be included in $X$ different reads on average,
allowing for the reads to be from either strand.  However, some sequencing
technologies produce biased data where the coverage across the genome is much
more variable than that expected by uniform, random sampling.

Reads may contain other information, such as {\it quality scores} or {\it
mate-pair} information, that can provide additional hints to the assembler.

It is also possible for reads to come from foreign DNA; for example, if a DNA
sample is obtained from grinding up plant or animal tissue, there could be some
bacterial cells, each with its own genome, contaminating the sample.  Therefore,
ideally an assembler should be prepared to completely ignore some reads.
However, this problem is not considered in this paper.

For the purposes of this paper, the problem of genome assembly is simplified by
assuming that the reads are error-free and uniformly (randomly) sampled from the
genome.  In addition, it is assumed there are no reads from foreign DNA, and the
reads are assumed to be unpaired, which means that mate-pair information, if
available, is not used.  In other words, a read is defined here as an exact
substring from either strand of any part of the genome.

Genomes may contain {\it repeats}, which are subsequences that occur multiple
times in the genome--- possibly adjacent to each other (a {\it tandem repeat}),
but not necessarily.  Repeats may be longer than the length of any individual
read, which makes the genome more difficult to assemble accurately.  However,
real genomes almost always contain repeats of substantial length, so genome
assembly algorithms must be able to handle repeats.

\section{Genome assembly vs. shortest common superstring}

Genome assembly is superficially similar to the shortest common superstring
(SCS) problem, which is to find the shortest possible string that contains every
string in a given set as substrings.  Genome assembly also requires finding a
longer string that contains all of a set of substrings.  However, the actual
genome may be more than one string, and it genome may be longer than the
shortest possible genome from which the reads could have been sampled, due to
repeats.  In addition,  genomes are double-stranded, and there may be other
complications with the reads (described in subsection \ref{subsec:reads}), such
as sequencing error.  Therefore, genome assembly is not the same as the SCS
problem, and in fact seems to be harder, despite the fact that the SCS problem
is already NP-complete\cite{Turner1989}.

In fact, some models of genome assembly have also been proven to be NP-complete
\cite{Medvedev2007}.  However, it is not acceptable to have a genome assembly
algorithm that takes exponential time to complete.  Instead, heuristic
algorithms that tend to produce good results but also tend to have a reasonable
running time must be designed.

\section{Overview of the fragment string graph algorithm}

This paper explores the genome assembly problem through an algorithm published
in 2005 by Eugene Myers\cite{Myers2005} that is based on the idea of the
fragment string assembly graph.  The algorithm provides a good overview of the
techniques that are used in genome assembly, especially since it draws on ideas
used in previous assemblers, such as the Celera assembler, which was used to
assemble the human genome for the first time\cite{Venter2001}.  In addition, the
algorithm shares some ideas with de Bruijn graph-based assemblers, such as
EULER-SR\cite{Pevzner2001}, although it does not use a de Bruijn graph for its
assembly model.  The algorithm also introduces some new ideas.

The overall fragment string graph algorithm is as follows: first, use overlaps
between reads to build a graph that models the assembly problem.  The idea is
that walks through this graph model a way in which reads may be assembled
together when the overlaps are used as evidence for joining two reads.  The next
step is to simplify and analyze the graph; and finally, find paths through the
graph are found to reconstruct the original genome.

\section{Overlaps}

\subsection{Definition of an overlap}
%\begin{definition}
	Consider two reads, $f$ and $g$, and their reverse-complements $f'$ and
	$g'$.  The reads $f$ and $g$ are said to {\bf exactly overlap} by some
	length $\LengthVar$ if and only if at least one of the following is
	true:
	\begin{enumerate}
		\item The last $\LengthVar$ bp of $f$ exactly match the first
		$\LengthVar$ bp of $g$.
		\item The last $\LengthVar$ bp of $f$ exactly match the first
		$\LengthVar$ bp of $g'$.
		\item The last $\LengthVar$ bp of $f'$ exactly match the first
		$\LengthVar$ bp of $g$.
		\item The last $\LengthVar$ bp of $f'$ exactly match the first
		$\LengthVar$ bp of $g'$.
	\end{enumerate}
%\end{definition}

Having four different conditions is required because reads may overlap in a
reverse-complement manner.  An overlap is reverse-complement if and only if one
read in the overlap is used in the original direction and the other read is used
in the reverse-complement direction.  Note that an overlap from condition (4) is
{\it not} a reverse-complement overlap, as it can equivalently be stated as the
last $\LengthVar$ bp of $g$ exactly match the last $\LengthVar$ bp of $f$.
\Figure{fig:overlap_types} shows the three fundamental types of overlaps that
may arise from this definition.

A read may overlap with itself; for example, a read may contain a suffix that
matches its prefix of the same length.  Such an overlap is called a {\it
self-overlap}.

Overlaps may also be {\it inexact}.  An inexact overlap is an overlap where
overlapped regions of the two reads do not match exactly (in forward or
reverse-complement form), but instead differ by a number of base-pair
substitutions, insertions, and/or deletions up to a predetermined upper bound,
such as 5\%.  However, inexact overlaps will not be considered further in this
paper.

An overlap $o$ is fully described by the 7-tuple $(f,\ f_{begin},\ f_{end},\ g,
\ g_{begin},\ g_{end},\ rc)$, where $f$ and $g$ are the two reads involved in the
overlap, $f_{begin}$ and $f_{end}$ are the starting and ending indices of the
overlapped region on the $f$ read, $g_{begin}$ and $g_{end}$ are the starting
and ending indices of the overlapped region on the $g$ read, and $rc$ is a
boolean that indicates whether the overlap is reverse-complement or not.  An
overlap therefore has two overlapped regions--- one on each read.  For exact
overlaps, the two overlapped regions are the same length; in other words,
$g_{end} - g_{begin} = f_{end} - f_{begin}$.

An {\it extreme point} occurs when an overlapped region extends to the beginning
or the end of the corresponding read.  An overlap always contains at least two
extreme points.

A {\it containing overlap} is an overlap in which the overlapped region of one
read, the {\it contained read}, is the entire read.  A special case of a
containing overlap is an overlap where the overlapped regions include the
entirety of both reads.  For an exact overlap, this can only happen if the two
reads are either identical or exact reverse-complements of each other.

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\begin{tikzpicture}=\ReadArrowType]
			\draw[->,style=thick] (0,0) -- (2,0);
			\draw[->,style=thick] (1.0,0.3) -- (3.0,0.3);
		\end{tikzpicture}
		%\vspace{3mm}
		%or (symmetrically)
		%\vspace{3mm}

		%\begin{tikzpicture}=\ReadArrowType]
			%\draw[->,style=thick] (2,0) -- (0,0);
			%\draw[->,style=thick] (3.0,0.3) -- (1.0,0.3);
		%\end{tikzpicture}
		\caption{``Normal'' overlap}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\begin{tikzpicture}=\ReadArrowType]
			\draw[->,style=thick] (0,0) -- (2,0);
			\draw[->,style=thick] (3,0.3) -- (1,0.3);
		\end{tikzpicture}
		\caption{``Innie'' overlap}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\begin{tikzpicture}=\ReadArrowType]
			\draw[->,style=thick] (2,0) -- (0,0);
			\draw[->,style=thick] (1.0,0.3) -- (3.0,0.3);
		\end{tikzpicture}
		\caption{``Outie'' overlap}
	\end{subfigure}
	\caption{The three types of overlaps.  The innie and outie overlaps are
	reverse-complement overlaps, while the normal overlap is not.  Note:
	with the normal overlap, there is a symmetric case that is not
	considered a distinct type of overlap here.}
	\label{fig:overlap_types}
\end{figure}

%\begin{enumerate}
	%\item ``Normal'' overlap
		%\begin{center}
			%\vspace{-0.5cm}
			%\begin{tikzpicture}[>=\ReadArrowType]
				%\draw[->,style=thick] (0,0) -- (2,0);
				%\draw[->,style=thick] (1.0,0.3) -- (3.0,0.3);
			%\end{tikzpicture}

			%\vspace{3mm}
			%or (symmetrically)
			%\vspace{3mm}

			%\begin{tikzpicture}[>=\ReadArrowType]
				%\draw[->,style=thick] (2,0) -- (0,0);
				%\draw[->,style=thick] (3.0,0.3) -- (1.0,0.3);
			%\end{tikzpicture}
		%\end{center}
	%\vspace{0.5cm}
	%\item ``Innie'' overlap
		%\begin{center}
			%\vspace{-0.5cm}
			%\begin{tikzpicture}[>=\ReadArrowType]
				%\draw[->,style=thick] (0,0) -- (2,0);
				%\draw[->,style=thick] (3,0.3) -- (1,0.3);
		%\end{tikzpicture} \end{center}
	%\vspace{0.5cm}
	%\item ``Outie'' overlap
		%\begin{center}
		%\vspace{-0.5cm}
		%\begin{tikzpicture}[>=\ReadArrowType]
				%\draw[->,style=thick] (2,0) -- (0,0);
				%\draw[->,style=thick] (1.0,0.3) -- (3.0,0.3);
		%\end{tikzpicture} \end{center}
%\end{enumerate}

Overlaps are important because two reads that overlap may come from adjacent
positions on the genome.  Although due to repeats, we cannot be certain that two
overlapping reads actually come from adjacent positions, we {\it can} say for
certain that two reads that do not overlap do not come from adjacent positions
on the genome.  Regardless of this, \Figure{fig:overlap_examples} shows how two
reads that overlap potentially could be combined to form a longer sequence.

\begin{figure}
		%\begin{tikzpicture}
			%\draw (0, 0) node[anchor=left] {Read 1:}	
			%\draw (0, -1) node[anchor=left] {Read 2:}	
			%\draw (0, -2) node[anchor=left] {Possible genome:}
		%\end{tikzpicture}
	\centering
	\begin{subfigure}[t]{0.455\textwidth}
		1: \hspace{0.7mm}{\tt $\rightarrow$ATATAT{GCTGGTTACTT}$\rightarrow$ } \\
		2: \hspace{0.7mm}{\tt \ \ \ \ \ \ $\rightarrow${GCTGGTTACTT}TGATAGATA$\rightarrow$ } \\
		G: {\tt $\rightarrow$ATATATGCTGGTTACTTTGATAGATA$\rightarrow$}
		\caption{A normal overlap between reads (1) and (2) and the
		implied way in which the two reads could be joined together to
		form a longer sequence (G)}
	\end{subfigure}
		\hspace{0.07\textwidth}
	\begin{subfigure}[t]{0.455\textwidth}
		1: \hspace{0.7mm}{\tt $\rightarrow$ATATAT{GCTGGTTACTT}$\rightarrow$ } \\
		2: \hspace{0.7mm}{\tt \ \ \ \ \ \ $\leftarrow${CGACCAATGAA}ACTATCTAT$\leftarrow$ } \\
		G: {\tt $\rightarrow$ATATATGCTGGTTACTTTGATAGATA$\rightarrow$}
		\caption{A reverse-complement overlap between reads (1) and
		(2)--- more specifically, an ``innie'' overlap--- and the
		implied way in which the two reads could be joined together to
		form a longer sequence (G)}
	\end{subfigure}
	\caption{Examples of normal and reverse-complement overlaps}
	\label{fig:overlap_examples}
\end{figure}

\subsection{Computing overlaps}

\subsubsection{Algorithms}

Now that the idea of an exact overlap has been formalized, what we would like to
do is compute all pairwise exact overlaps of minimum length $L$ among the reads
that were provided as input to the assembler.

The naive way to do this is to consider every pair of reads in the input,
including only distinct pairs but also including the special cases of each read
paired with itself, and search for each of the types of overlaps between the two
reads in each pair.  If there are $N$ reads in the input, this algorithm will
need to consider $\frac{N^2}{2} + N$ pairs of reads, and the time spent on each
read pair will depend several factors, including the minimum overlap length and
the read lengths.  But even if we could somehow spend constant time on each read
pair, this algorithm is much too slow because the running time rises quadraticly
with respect to the number of reads.  This is important because there can easily
be millions of reads in the input.

A number of faster algorithms for computing overlaps have been designed.  One of
the easier ones to understand is the {\it seed-and-extend} algorithm.  It works
by indexing the reads by short subsequences of a certain length (less than or
equal to than the minimum overlap length) and then only comparing reads that
actually share a subsequence.  Each of these short subsequences is called a {\it
seed}.  Two reads may share a seed in either a forward or reverse-complement
manner.  Given two reads that share a seed, the seed can be extended outwards in
both directions in order to find a maximal matched region, that may be either
forward or reverse-complement, between the two reads.  Then, this maximal
matched region is compared against the definition of an overlap.  In particular,
it must be at least as long as the minimum overlap length, it must have least 2
extreme points over the two reads, and it cannot be the prefix or suffix of both
reads if the match does not extend to the opposite end of at least one of the
reads.  If all of these conditions are met and the same overlap was not already
found through another seed in the same two reads, this overlap is added to the
set of overlaps.

The running time of the seed-and-extend algorithm, as described above, is
typically much faster than the naive algorithm, although it is highly dependent
on the data.  For a string of the genome of length $G$ and with a seed length
$k$, there will be at most $G-k+1$ canonical seeds.\footnote{The canonical form
of a DNA sequence and its reverse-complement is the lexicographically lesser of
the two.  Here, we refer canonical form of each seed, because we wish to compare
reads that share a seed in either a forward or reverse-complement manner.}  For
each of these seeds, the reads containing it will be examined exhaustively in a
pairwise manner, which takes quadratic time with respect to the number of reads
sharing that seed.  Since the more densely reads are sampled from the genome,
the more reads will contain each seed,  the running time of the seed-and-extend
algorithm rises quadratically with regards to read density.  In addition, the
number of read pairs the algorithm considers for a specific seed also rises
quadratically with the number of times that seed is repeated in the genome due
to genomic repeats.  Overall, the seed-and-extend algorithm is not ideal and is
still a bottleneck of the entire assembly algorithm, despite the fact that it is
much faster than the naive algorithm (except in degenerate cases, such as a
``genome'' that is entirely a single repeated letter).

\subsubsection{Implementation}

For this project, the seed-and-extend algorithm for computing overlaps was
implemented as the program {\tt compute-overlaps}.  It takes as input a file
that contains a list of reads, as well as a parameter that specifies the minimum
overlap length $L$.  It produces as output (via a data structure serialized to a
file) all exact pairwise overlaps of minimum length $L$ among reads in the input
file, including reverse-complement overlaps and self-overlaps.  The running time
of the algorithm was discussed above.  The memory usage is linear with respect
to the total length of the reads and the number of overlaps, which likely could
be improved.

\begin{comment}
\begin{algorithm}
\caption{{\sc ComputeExactOverlapsNaive}($S$, $L$)}
\begin{algorithmic}
	%\FOR{{\bf each} distinct}
	\STATE b
\end{algorithmic}
\end{algorithm}

\newcommand{\OccVar}{\omega}
%\newcommand{\OccOne}{{\OccVar}_1}
%\newcommand{\OccTwo}{{\OccVar}_2}
\newcommand{\OccOne}{{\tt occ1}}
\newcommand{\OccTwo}{{\tt occ2}}
\newcommand{\SeedVar}{{\tt seed}}
\newcommand{\OccList}{{\tt occurrenceSet}}
\newcommand{\OverlapSet}{{\tt overlapSet}}
\newcommand{\OccMap}{{\tt occurrenceMap}}
\newcommand{\PosOne}{{\tt pos1}}
\newcommand{\PosTwo}{{\tt pos2}}
\newcommand{\Len}{{\tt len}}
\newcommand{\RightExtend}{{\tt rightExtend}}
\newcommand{\LeftExtend}{{\tt leftExtend}}
\newcommand{\ReadSet}{{\tt readSet}}
\newcommand{\minOverlapLen}{{\tt minOverlapLen}}
\newcommand{\readOneBeg}{{\tt read1Begin}}
\newcommand{\readOneEnd}{{\tt read1End}}
\newcommand{\readTwoBeg}{{\tt read2Begin}}
\newcommand{\readTwoEnd}{{\tt read2End}}
\newcommand{\numExtremePoints}{{\tt numExtremePoints}}

\begin{algorithm}
\caption{{\sc ComputeExactOverlapsSeedAndExtend}($\ReadSet$, $\minOverlapLen$)}
\begin{algorithmic}
	%\REQUIRE{$S$ is a list of DNA sequences}
	%\REQUIRE{$L$ is a positive integer that is the minimum overlap length}
	\STATE{Let $k$ be a positive integer less than or equal to
	$\minOverlapLen$.}
	\STATE{Let $\OccMap$ be a hash table that maps DNA sequences to sets of
		$k$-mer occurrences.}
	\STATE{Let $\OverlapSet$ be an empty set of overlaps.}
	\FOR{{\bf each} sequence $s \in \ReadSet$}
		\FOR{{\bf each} canonical $k$-mer $K \in r$}
			\STATE{Add the occurrence of $K$ to $\OccMap[K]$}
		\ENDFOR
	\ENDFOR
	\FOR{{\bf each} $(\SeedVar,\ \OccList) \in \OccMap$}
		\FOR{{\bf each} distinct pair of $k$-mer occurrences $\OccOne,
		\OccTwo \in \OccList$}
			\IF{the read ID of $\OccOne$ is greater than the read ID
			of $\OccTwo$}
				\STATE{Swap $\OccOne$ and $\OccTwo$}
			\ENDIF
			\IF{$\OccOne$ and $\OccTwo$ are both forward or both
			reverse-complement}
				\STATE{${\tt rc} \gets$ {\bf true}}
			\ELSE
				\STATE{${\tt rc} \gets$ {\bf false}}
			\ENDIF
			\STATE{$f \gets$ the read containing $\OccOne$}
			\STATE{$g \gets$ the read containing $\OccTwo$}
			\STATE{$\PosOne \gets$ the position within $f$ of $\OccOne$}
			\STATE{$\PosOne \gets$ the position within $g$ of $\OccTwo$}
			\STATE{$\Len \gets k$}
			\IF{${\tt rc}$}
				\STATE{$g' \gets$ the reverse complement of $g$}
				\STATE{${\tt \LeftExtend} \gets$ the number of
				additional bp to the left of the seed that
				match, comparing $f$ with $g'$}
				\STATE{${\tt \RightExtend} \gets$ the number of
				additional bp to the right of the seed that
				match, comparing $f$ with $g'$}
				\STATE{$\PosTwo \gets \PosTwo - {\tt
				\RightExtend}$}
			\ELSE
				\STATE{${\tt \LeftExtend} \gets$ the number of
				additional bp to the left of the seed that
				match, comparing $f$ with $g$}
				\STATE{${\tt \RightExtend} \gets$ the number of
				additional bp to the right of the seed that
				match, comparing $f$ with $g$}
				\STATE{$\PosTwo \gets \PosTwo - {\tt \LeftExtend}$}
			\ENDIF
			\STATE{$\PosOne \gets \PosOne - {\tt \LeftExtend}$}
			\STATE{$\Len \gets \Len + {\tt \LeftExtend} + {\tt \RightExtend}$}
			\IF{$\Len < \minOverlapLen$} 
				\STATE{\bf continue}
			\ENDIF
			\STATE{$\readOneBeg \gets \PosOne$}
			\STATE{$\readOneEnd \gets \PosOne + \Len - 1$}
			\STATE{$\readTwoBeg \gets \PosTwo$}
			\STATE{$\readTwoEnd \gets \PosTwo + \Len - 1$}
			\STATE{$\numExtremePoints \gets 0$}
			\IF{$\readOneBeg = 0$}
				\STATE{$\numExtremePoints \gets \numExtremePoints + 1$}
			\ENDIF
			\IF{$\readOneEnd = {\sc Length}(f) - 1$}
				\STATE{$\numExtremePoints \gets \numExtremePoints + 1$}
			\ENDIF
			\IF{$\readTwoBeg = 0$}
				\STATE{$\numExtremePoints \gets \numExtremePoints + 1$}
			\ENDIF
			\IF{$\readTwoEnd = {\sc Length}(g) - 1$}
				\STATE{$\numExtremePoints \gets \numExtremePoints + 1$}
			\ENDIF


			%\STATE{Maximally extend the occurrence of $\SeedVar$ at
			%$\OccOne$ and $\OccTwo$ outwards in both directions}
			%\STATE{${\tt pos1} \gets$ the beginning of the maximally
			%matched region on the read containing $\OccOne$}
			%\STATE{${\tt pos2} \gets$ the beginning of the maximally
			%matched region on the read containing $\OccTwo$}
			%\STATE{${\tt plen} \gets$ the length of the maximall
			%matched region on the read containing $\OccTwo$}
		\ENDFOR
	\ENDFOR
\end{algorithmic}
\end{algorithm}
\end{comment}


\section{Building the fragment string assembly graph}


\section*{Acknowledgments}

Acknowledgements

\bibliographystyle{plain}
\bibliography{refs}

\end{document}
