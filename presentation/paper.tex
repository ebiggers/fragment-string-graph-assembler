\documentclass[12pt]{article}
\usepackage[left=3.3cm,right=3.3cm,bottom=3.0cm,top=3.0cm]{geometry}
\usepackage{float}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{subcaption}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{comment}
\usepackage{mathptmx}
\usepackage{microtype}
\usepackage{array}
\usepackage{grffile}
\usepackage{threeparttable}
%\usepackage{hyperref}
%\usepackage{amsthm}

%\usepackage[nofiglist,notablist]{endfloat}
%\renewcommand{\efloatseparator}{\mbox{}}

%\newcommand{\nodecolor}{blue!20}
\newcommand{\nodecolor}{black!0}
%\newcommand{\specialnodecolor}{green!25}
\newcommand{\specialnodecolor}{black!10}

\usetikzlibrary{arrows}

%\floatstyle{boxed}
%\restylefloat{figure}

%\theoremstyle{definition}
%\newtheorem{definition}{Definition}

\newcommand{\LengthVar}{L}
\newcommand\Base[1]{{\tt #1}}
\newcommand{\ReadArrowType}{latex}
\newcommand{\Figure}[1]{Figure \ref{#1}}
\newcommand{\Subfigure}[1]{Figure \ref{#1}}
\newcommand{\Section}[1]{Section \ref{#1}}
\newcommand{\Subsection}[1]{Section \ref{#1}}
\newcommand{\Algorithm}[1]{Algorithm \ref{#1}}

\newcommand{\KeyTerm}[1]{{\it #1}}
\newcommand{\ProgramName}[1]{{\tt #1}}
\newcommand{\BidirectedEdgeForward}[2]{
		\tikz[>=triangle 45,baseline]
		\draw[>->,thin] (0,0.1) node[anchor=east] {#1} --
					    (0.8,0.1) node[anchor=west] {#2};}
\newcommand{\BidirectedEdgeInnie}{
		\tikz[>=triangle 45,baseline]
		\draw[>-<,thin] (0,0.1) -- (0.8,0.1) node {\ \ } ;}
\newcommand{\BidirectedEdgeOutie}{
		\tikz[>=triangle 45,baseline]
		\draw[<->,thin] (0,0.1) --(0.8,0.1) node {\ \ };}

\title{A Bidirected String Graph Model for Genome Assembly}
\author{Eric Biggers}
\date{December 12, 2012}


\begin{document}
\maketitle

\begin{abstract}

Sequencing an organism's genome is an important step to further genetic research
on that organism.  However, currently available sequencing technologies can only
sequence short fragments of DNA.  As a result, the whole-genome shotgun
sequencing approach to genome sequencing relies on breaking up a sample of
genomic DNA into short fragments, sequencing these fragments, then using a
program called a {\em genome assembler} to put together these short sequences to
reconstruct the original genome.  This paper provides an introduction and
formalization of the genome assembly problem, then introduces a model and
algorithm for genome assembly that is based on a special type of graph called a
\KeyTerm{bidirected string graph}.  \end{abstract}

\tableofcontents

\section{Introduction to genome sequencing and assembly}

\subsection{Definition of a genome}

\label{sec:genome}

Every living organism contains a collection of hereditary material called a
\KeyTerm{genome}.  Typically, each cell of a multicellular organism contains a
complete copy of that organism's genome.  A genome consists of one or more DNA
(\KeyTerm{deoxyribonucleic acid}) molecules in the form of
\KeyTerm{chromosomes}.  DNA is a double-stranded molecule, each strand of which
is a polymer of \KeyTerm{nucleotides}.  A nucleotide, together with the
corresponding nucleotide on the opposite strand, is called a \KeyTerm{base pair}
(abbreviation: \KeyTerm{bp}).  In DNA, there are four possible nucleotides:
adenine, cytosine, guanine, and thymine, which are abbreviated as \Base{A},
\Base{C}, \Base{G}, and \Base{T}, respectively.  \Base{A} always pairs with T on
the opposite strand, and \Base{C} always pairs with \Base{G} on the opposite strand.
In addition, each strand has a direction, and the two strands of a DNA molecule
are directed opposite one another.  Furthermore, a DNA molecule may be circular,
as is usually the case for bacterial chromosomes.

Based on these biological facts, a genome is formally defined, for the purposes
of this paper, as a set of possibly circular, double-stranded strings of the
symbols \Base{A}, \Base{C}, \Base{G}, and \Base{T}, where double-stranded has
the meaning indicated above (the two strands run in opposite directions, and the
pairings \Base{A}---\Base{T} and \Base{C}---\Base{G} always hold).

This definition does not account for the fact that the genomes of diploid and
polyploid organisms, including most plants and animals, contain multiple
slightly-differing copies of each chromosome.  In this case, this definition
will consider each copy of each chromosome to be a completely different string
in the genome, unless the copies are completely identical.

Genomes vary widely in size, from several thousand base pairs to many billion
base pairs, depending on the organism (see Table \ref{tab:GenomeSizes}).

\begin{table}[H]
	\begin{center}
	\caption{Approximate genome sizes of selected organisms}
		\label{tab:GenomeSizes}
		\begin{threeparttable}
			\begin{tabular}{|l|>{\arraybackslash}p{5.2cm}|}
				%\hline
				%$\phi$X174 bacteriophage &  $\sim$5,000 bp \\
				%\hline
				%Human mitochondrion &  $\sim$16,000 bp \\
				\hline
				{\bf Organism} & {\bf Approximate genome size} \\
				\hline
				{\it Variola} virus (smallpox) \tnote{1} &  186,000 bp \cite{smallpox}\\
				\hline
				{\it E. coli} (a bacterium) & 4,600,000 bp \\
				\hline
				{\it Ananas comosus} (domesticated pineapple) & 500,000,000 bp \\
				\hline
				{\it Zea mays} (domesticated corn) & 2,400,000,000 bp \cite{maize} \\
				\hline
				{\it Homo sapiens} (human)       &  3,200,000,000 bp \\
				\hline
			\end{tabular}
			\begin{tablenotes}
				\item [1] Technically, viruses are not organisms, but they still
				have genomes.
				%Actually, some viruses have genomes made of RNA,
				%not DNA, but this is not considered in this paper.
			\end{tablenotes}
		\end{threeparttable}
	\end{center}
\end{table}

\subsection{Complement and reverse-complement sequences}

The \KeyTerm{complement} of a single-stranded DNA sequence $S$ is the
single-stranded DNA sequence obtained by making the replacements $\Base{A}
\leftrightarrow \Base{T}$ and $\Base{C} \leftrightarrow \Base{G}$.  The
\KeyTerm{reverse-complement} of a single-stranded DNA sequence $S$ is the
complement of $S$ reversed.  Physically, the reverse-complement of a
single-stranded DNA sequence corresponds to the corresponding sequence on the
other strand of the DNA molecule.  It is the reverse-complement, not the
``regular'' complement, because the two strands of a DNA molecule run in
opposite directions.

The \KeyTerm{canonical form} of a DNA sequence $S$ is the lexicographically
lesser of $S$ and its reverse-complement $S'$.  This concept is useful in
algorithms where a DNA sequence and its reverse-complement are considered
equivalent.

\subsection{Genome sequencing}

\KeyTerm{DNA sequencing} is the process of determining the base pair sequence of
(\KeyTerm{sequencing}) one or more DNA molecules.  \KeyTerm{Genome sequencing}
is the process of sequencing of all the DNA molecules that make up a genome.

Sequencing a DNA molecule is very difficult because it is in fact an actual
molecule, which makes each base pair much too small to be directly observed.
Therefore, indirect laboratory techniques must be used.  Advances in these
techniques are progressing rapidly, and they can now be performed by automated
machines.  However, every technique suffers from the limitation that only short
fragments of DNA several dozen to several thousand base pairs long can be
sequenced.

Therefore, to sequence an entire genome, which may be millions of base pairs
long, the DNA from the whole genome must be broken into much smaller fragments,
which are then sequenced.\footnote{This specifically refers to the
\KeyTerm{whole-genome shotgun sequencing} approach to genome sequencing rather
than alternatives such as \KeyTerm{BAC-to-BAC} sequencing that are able to
restrict sequences to certain regions of the genome in order to make sequencing
the genome easier (currently, at the disadvantage of increased cost and much more
non-computational work).} Following this, the original genome must be
computationally reconstructed by a computer program called a \KeyTerm{genome
assembler} in a process called \KeyTerm{genome assembly}.  \KeyTerm{Genome
sequencing} therefore refers to the entire process of sequencing a genome,
including both lab work and computational work, while \KeyTerm{genome assembly}
only refers to the computational work.\footnote{It usually also takes some
technology-specific computational work to actually prepare the sequences for
assembly; for example, a series of digital photographs of clumps of
fluorescently labeled molecules might need to be interpreted as reads using
image-processing algorithms.  However, these programs and/or algorithms
generally have already been developed by the manufacturer of the sequencing
machine and are assumed to work fairly well, so ``genome assembly'' does not cover these
algorithms.  Still, assemblers may be tuned for specific sequencing
technologies.}

\subsection{Genome assembly}

\label{subsec:reads}

The goal of genome assembly is to reconstruct a genome, as defined in
\Section{sec:genome}, given a set of substrings that may originate from any
strand of any DNA molecule in the genome.  Each substring is called a
\KeyTerm{read} and is the sequence of some DNA that was sequenced by the
sequencing machine.  In general, reads may contain errors, including
\KeyTerm{substitutions}, where a base pair in the read was incorrectly read as
some other base pair, as well as \KeyTerm{insertions}, where a sequence of one
or more random base pairs have been inserted into some position in the read, and
\KeyTerm{deletions}, where a sequence of one or more base pairs from the
original genome is missing from the interior of the read.  Reads are expected to
be uniformly distributed on the genome with a certain coverage $X$ depending on
how much data was collected, meaning that each base pair in the original genome
is expected to be included in $X$ different reads on average, allowing for the
reads to be from either strand.  However, some sequencing technologies produce
biased data where the coverage across the genome is much more variable than that
expected by uniform, random sampling.

Reads may contain other information, such as \KeyTerm{quality scores} or
\KeyTerm{mate-pair} information, that can provide additional hints to the
assembler.

It is also possible for reads to come from foreign DNA; for example, if a DNA
sample is obtained by grinding up plant or animal tissue, there could be some
bacterial cells, each with its own genome, contaminating the sample.  Ideally,
an assembler should be prepared to completely ignore a read if it seems too
unusual.  However, this problem is not considered in this paper.

For the purposes of this paper, the problem of genome assembly is simplified by
assuming the following characteristics of the reads:

\begin{itemize}
	\item The reads are error-free and uniformly sampled from the genome.
	\item There are no reads from foreign DNA.
	\item The reads are unpaired, meaning that mate-pair information, if
available, is not used.
\end{itemize}

In other words, a read is defined here as an exact substring from either strand
of any part of the genome.

Genomes may contain \KeyTerm{repeats}, which are subsequences that occur
multiple times in the genome--- possibly adjacent to each other,
%(a \KeyTerm{tandem repeat})
but not necessarily.  The number of times a
subsequence occurs in the genome is referred to as its \KeyTerm{copy number}.
Repeats may be longer than the length of any individual read, which makes the
genome more difficult to assemble accurately.  However, real genomes almost
always contain repeats of substantial length, so assemblers must be able to
handle repeats.

The output of an assembler may be a list of \KeyTerm{contigs}, which are
continuous sequences of DNA that were assembled and therefore are believed to
exist in the original genome.  Each contig should be much longer than the
original reads.  Ideally, if the original genome contains $N$ separate strings,
there should be $N$ contigs, each of which is one of the genomic strings.
However, in general there will be more than $N$ contigs because it is rarely
possible to perfectly assemble the genome.

\subsection{Genome assembly vs. shortest common superstring}

Genome assembly is superficially similar to the shortest common superstring
problem, which is to find the shortest possible string that contains every
string in a given set as substrings.  Genome assembly also requires finding a
longer string that, roughly, contains every string in  a set of substrings.
However, the actual genome may be more than one string, and the genome may also
be longer than the shortest possible genome from which the reads could have been
sampled, due to repeats.  In addition,  genomes are double-stranded, and there
may be other complications with the reads, such as sequencing error.  Therefore,
genome assembly is not the same as the shortest common superstring problem, and
in some ways seems to be harder, despite the fact that the shortest common
superstring problem is already NP-complete\cite{Turner1989}.

In fact, some models of genome assembly have also been proven to be
NP-complete\cite{Medvedev2007}.  However, it is not acceptable to have a genome
assembly algorithm that takes exponential time to complete.  Instead, heuristic
algorithms that tend to produce good results on real inputs while still having
reasonable running times must be designed.

\section{Overview of the fragment string graph algorithm}

This paper explores the genome assembly problem through an algorithm published
in 2005 by Eugene Myers that is based on the idea of the fragment string
assembly graph\cite{Myers2005}.  The algorithm provides a good overview of the
techniques that are used in genome assembly, especially since it draws on ideas
used in previous assemblers, such as the Celera assembler, which was used to
assemble the human genome for the first time\cite{Venter2001}.  In addition, the
algorithm shares some ideas with de Bruijn graph-based assemblers, such as
EULER-SR\cite{Pevzner2001}, although it does not use a de Bruijn graph for its
assembly model.  In fact, the algorithm is called the {\em fragment} string
graph algorithm because the graph is built directly from the sequenced fragments
(reads), rather than subsequences ($k$-mers) taken from them.

The algorithm also introduces new ideas that were not used in previous
publications or assemblers.

The overall fragment string graph algorithm can be described as follows.  First,
use overlaps between reads to build a graph that models the assembly problem.
The idea is that walks through this graph model a way in which reads may be
assembled together consistently when the overlaps are used as evidence for
joining pairs of reads.  The next step is to simplify and analyze the graph, and
the last step is to find paths through the graph to reconstruct the original
genome.\footnote{The fragment string graph algorithm, as described in
\cite{Myers2005}, does not involve any finishing steps such as scaffolding
(using mate-pair information to improve the assembly), although ideas for doing
this are outlined in \cite{Medvedev2009}.  However, in this paper we assume that
no mate-pair information is available.}

\section{Overlaps}

\subsection{Definition of an overlap}
%\begin{definition}
	Consider two reads, $f$ and $g$, and their reverse-complements $f'$ and
	$g'$.  The reads $f$ and $g$ are said to \KeyTerm{exactly overlap} by some
	length $\LengthVar$ if and only if at least one of the following is true:
	\begin{itemize}
		\item The last $\LengthVar$ bp of $f$ exactly match the first
		$\LengthVar$ bp of $g$.
		\item The last $\LengthVar$ bp of $f$ exactly match the first
		$\LengthVar$ bp of $g'$.
		\item The last $\LengthVar$ bp of $f'$ exactly match the first
		$\LengthVar$ bp of $g$.
		\item The last $\LengthVar$ bp of $f'$ exactly match the first
		$\LengthVar$ bp of $g'$.
	\end{itemize}
%\end{definition}

Having four different conditions is required because reads may overlap in a
reverse-complement manner.  An overlap is reverse-complement if and only if one
read in the overlap is used in the original direction and the other read is used
in the reverse-complement direction.  Note that an overlap from the last
condition is {\em not} a reverse-complement overlap, as it can equivalently be
stated as the last $\LengthVar$ bp of $g$ exactly match the first $\LengthVar$
bp of $f$.  \Figure{fig:overlap_types} shows the three fundamental types of
overlaps that may arise from this definition.

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\begin{tikzpicture}[>=\ReadArrowType]
			\draw[->,style=thick] (0,0) -- (2,0);
			\draw[->,style=thick] (1.0,0.3) -- (3.0,0.3);
		\end{tikzpicture}
		%\vspace{3mm}
		%or (symmetrically)
		%\vspace{3mm}

		%\begin{tikzpicture}=\ReadArrowType]
			%\draw[->,style=thick] (2,0) -- (0,0);
			%\draw[->,style=thick] (3.0,0.3) -- (1.0,0.3);
		%\end{tikzpicture}
		\caption{``Normal'' overlap}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\begin{tikzpicture}[>=\ReadArrowType]
			\draw[->,style=thick] (0,0) -- (2,0);
			\draw[->,style=thick] (3,0.3) -- (1,0.3);
		\end{tikzpicture}
		\caption{``Innie'' overlap}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\begin{tikzpicture}[>=\ReadArrowType]
			\draw[->,style=thick] (2,0) -- (0,0);
			\draw[->,style=thick] (1.0,0.3) -- (3.0,0.3);
		\end{tikzpicture}
		\caption{``Outie'' overlap}
	\end{subfigure}
	\caption{The three types of overlaps.  The innie and outie overlaps are
	reverse-complement overlaps, while the normal overlap is not.  Note:
	with the normal overlap, there is a symmetric case that is not
	considered a distinct type of overlap here.}
	\label{fig:overlap_types}
\end{figure}

A read may overlap with itself; for example, a read may contain a suffix that
matches its prefix of the same length.  Such an overlap is called a
\KeyTerm{self-overlap}.

Overlaps may also be \KeyTerm{inexact}.  An inexact overlap is an overlap where
the overlapped regions of the two reads do not match exactly (in either a
forward or reverse-complement manner), but instead differ by a number of
base-pair substitutions, insertions, and/or deletions up to a predetermined
upper bound, such as 5\%.  However, inexact overlaps will not be considered
further in this paper.

An overlap $o$ is fully described by the 7-tuple $(f,\ f_{begin},\ f_{end},\ g,
\ g_{begin},\ g_{end},\ rc)$, where $f$ and $g$ are the two reads involved in the
overlap, $f_{begin}$ and $f_{end}$ are the starting and ending indices of the
overlapped region on the $f$ read, $g_{begin}$ and $g_{end}$ are the starting
and ending indices of the overlapped region on the $g$ read, and $rc$ is a
boolean that indicates whether the overlap is reverse-complement or not.  An
overlap therefore has two overlapped regions--- one on each read.  For exact
overlaps, the two overlapped regions are the same length; in other words,
$g_{end} - g_{begin} = f_{end} - f_{begin}$.

An \KeyTerm{extreme point} occurs when an overlapped region extends to the
beginning or the end of the corresponding read.  An overlap always contains at
least two extreme points.

A \KeyTerm{containing overlap} is an overlap in which the overlapped region of
one read, the \KeyTerm{contained read}, is the entire read.  A special case of a
containing overlap is an overlap where the overlapped regions include the
entirety of both reads.  For an exact overlap, this can only happen if the two
reads are either identical or exact reverse-complements of each other.


%\begin{enumerate}
	%\item ``Normal'' overlap
		%\begin{center}
			%\vspace{-0.5cm}
			%\begin{tikzpicture}[>=\ReadArrowType]
				%\draw[->,style=thick] (0,0) -- (2,0);
				%\draw[->,style=thick] (1.0,0.3) -- (3.0,0.3);
			%\end{tikzpicture}

			%\vspace{3mm}
			%or (symmetrically)
			%\vspace{3mm}

			%\begin{tikzpicture}[>=\ReadArrowType]
				%\draw[->,style=thick] (2,0) -- (0,0);
				%\draw[->,style=thick] (3.0,0.3) -- (1.0,0.3);
			%\end{tikzpicture}
		%\end{center}
	%\vspace{0.5cm}
	%\item ``Innie'' overlap
		%\begin{center}
			%\vspace{-0.5cm}
			%\begin{tikzpicture}[>=\ReadArrowType]
				%\draw[->,style=thick] (0,0) -- (2,0);
				%\draw[->,style=thick] (3,0.3) -- (1,0.3);
		%\end{tikzpicture} \end{center}
	%\vspace{0.5cm}
	%\item ``Outie'' overlap
		%\begin{center}
		%\vspace{-0.5cm}
		%\begin{tikzpicture}[>=\ReadArrowType]
				%\draw[->,style=thick] (2,0) -- (0,0);
				%\draw[->,style=thick] (1.0,0.3) -- (3.0,0.3);
		%\end{tikzpicture} \end{center}
%\end{enumerate}

Overlaps are important because two reads that overlap may have come from
adjacent positions on the genome.  Although due to repeats, we cannot be certain
that two overlapping reads actually came from adjacent positions, we {\em can}
be certain that two reads that do not overlap did not come from adjacent
positions.  Regardless of this, \Figure{fig:overlap_examples} shows how two
reads that overlap potentially could be combined to form a longer sequence.

\begin{figure}
		%\begin{tikzpicture}
			%\draw (0, 0) node[anchor=left] {Read 1:}
			%\draw (0, -1) node[anchor=left] {Read 2:}
			%\draw (0, -2) node[anchor=left] {Possible genome:}
		%\end{tikzpicture}
	\centering
	\begin{subfigure}[t]{0.455\textwidth}
		1: \hspace{0.7mm}{\tt $\rightarrow$ATATAT{GCTGGTTACTT}$\rightarrow$ } \\
		2: \hspace{0.7mm}{\tt \ \ \ \ \ \ $\rightarrow${GCTGGTTACTT}TGATAGATA$\rightarrow$ } \\
		G: {\tt $\rightarrow$ATATATGCTGGTTACTTTGATAGATA$\rightarrow$}
		\caption{A normal overlap between reads (1) and (2) and the
		implied way in which the two reads could be joined together to
		form a longer sequence (G)}
	\end{subfigure}
		\hspace{0.07\textwidth}
	\begin{subfigure}[t]{0.455\textwidth}
		1: \hspace{0.7mm}{\tt $\rightarrow$ATATAT{GCTGGTTACTT}$\rightarrow$ } \\
		2: \hspace{0.7mm}{\tt \ \ \ \ \ \ $\leftarrow${CGACCAATGAA}ACTATCTAT$\leftarrow$ } \\
		G: {\tt $\rightarrow$ATATATGCTGGTTACTTTGATAGATA$\rightarrow$}
		\caption{A reverse-complement overlap between reads (1) and
		(2)--- more specifically, an ``innie'' overlap--- and the
		implied way in which the two reads could be joined together to
		form a longer sequence (G)}
	\end{subfigure}
	\caption{Examples of normal and reverse-complement overlaps}
	\label{fig:overlap_examples}
\end{figure}

\subsection{Computing overlaps}

\subsubsection{Algorithms}

Now that the idea of an exact overlap has been formalized, our goal is to
compute all pairwise exact overlaps of some minimum length $L$ among the reads
that were provided as input to the assembler.  The chosen value of $L$ must be
balanced so that we can find enough overlaps to adequately cover the genome
(small $L$ better) but still exclude most spurious overlaps (large $L$ better).

The naive way to compute overlaps is to consider every pair of reads in the
input, including only distinct pairs but also including each read paired with
itself, and search for each of the types of overlaps between the two reads in
each pair.  If there are $N$ reads in the input, this algorithm will need to
consider $\frac{N^2}{2} + N$ pairs of reads. The time spent on each read pair
will depend several factors, including the minimum overlap length $L$ and the
read lengths.  But even if we somehow could spend constant time on each read
pair, this naive algorithm would be prohibitively slow because the running time
rises quadraticly with respect to the number of reads, and there can easily be
millions of reads in the input.

A number of faster algorithms for computing overlaps have been designed.  One of
the easier ones to understand is the \KeyTerm{seed-and-extend} algorithm.  It
works by indexing the reads by short subsequences of a certain length (less than
or equal to than the minimum overlap length $L$) and then only comparing reads
that actually share a subsequence.  Each of these short subsequences is called a
\KeyTerm{seed}.  Two reads may share a seed in either a forward or
reverse-complement manner.  Given two reads that share a seed, the seed can be
extended outwards in both directions to find a maximal matched region (that may
be either forward or reverse-complement) between the two reads.  Then, this
maximal matched region is compared against the definition of an overlap.  In
particular, it must have length greater than or equal to $L$, it must have least
2 extreme points over the two reads, and it cannot be the prefix or suffix of
both reads if the match does not extend to the opposite end of at least one of
the reads.  If all of these conditions are met, this maximal matched region is
translated into an overlap and added to the set of overlaps if not already
present.

The running time of this seed-and-extend algorithm is
typically much faster than the naive algorithm, although it is highly dependent
on the data.  The number of distinct seeds is at worst linear with respect to
the genome length.
%of a DNA sequence and its reverse-complement is the lexicographically lesser of
%the two.  Here, we refer canonical form of each seed, because we wish to
%compare reads that share a seed in either a forward or reverse-complement
%manner.}
For each of these distinct seeds, the reads containing it are examined pairwise,
which takes quadratic time with respect to the number of reads sharing the
seed.  Since more reads will contain each seed when the reads are sampled more
densely from the genome, the running time of the seed-and-extend algorithm rises
quadraticly with respect to read density.  In addition, the number of read
pairs the algorithm considers for a specific seed also rises quadraticly with
the number of times that seed is repeated in the genome due to genomic repeats.
Overall, the seed-and-extend algorithm is not ideal and is still a bottleneck of
the entire assembly algorithm, despite the fact that it is much faster than the
naive algorithm (except in degenerate cases, such as a ``genome'' that is
entirely a single repeated letter).

\subsubsection{Implementation}

For this project, the seed-and-extend algorithm for computing overlaps was
implemented as the program \ProgramName{compute-overlaps}.  It takes as input a
file that contains a list of reads and a parameter that specifies the minimum
overlap length $L$.  It produces as output, via a data structure serialized to a
file, all exact pairwise overlaps of minimum length $L$ among the input reads,
including reverse-complement overlaps and self-overlaps.  The running time of
the algorithm was discussed above.  The memory usage is linear with respect to
the total length of the reads and the number of overlaps, which likely could be
improved.

\begin{comment}
\begin{algorithm}
\caption{{\sc ComputeExactOverlapsNaive}($S$, $L$)}
\begin{algorithmic}
	%\FOR{{\bf each} distinct}
	\STATE b
\end{algorithmic}
\end{algorithm}

\newcommand{\OccVar}{\omega}
%\newcommand{\OccOne}{{\OccVar}_1}
%\newcommand{\OccTwo}{{\OccVar}_2}
\newcommand{\OccOne}{{\tt occ1}}
\newcommand{\OccTwo}{{\tt occ2}}
\newcommand{\SeedVar}{{\tt seed}}
\newcommand{\OccList}{{\tt occurrenceSet}}
\newcommand{\OverlapSet}{{\tt overlapSet}}
\newcommand{\OccMap}{{\tt occurrenceMap}}
\newcommand{\PosOne}{{\tt pos1}}
\newcommand{\PosTwo}{{\tt pos2}}
\newcommand{\Len}{{\tt len}}
\newcommand{\RightExtend}{{\tt rightExtend}}
\newcommand{\LeftExtend}{{\tt leftExtend}}
\newcommand{\ReadSet}{{\tt readSet}}
\newcommand{\minOverlapLen}{{\tt minOverlapLen}}
\newcommand{\readOneBeg}{{\tt read1Begin}}
\newcommand{\readOneEnd}{{\tt read1End}}
\newcommand{\readTwoBeg}{{\tt read2Begin}}
\newcommand{\readTwoEnd}{{\tt read2End}}
\newcommand{\numExtremePoints}{{\tt numExtremePoints}}

\begin{algorithm}
\caption{{\sc ComputeExactOverlapsSeedAndExtend}($\ReadSet$, $\minOverlapLen$)}
\begin{algorithmic}
	%\REQUIRE{$S$ is a list of DNA sequences}
	%\REQUIRE{$L$ is a positive integer that is the minimum overlap length}
	\STATE{Let $k$ be a positive integer less than or equal to
	$\minOverlapLen$.}
	\STATE{Let $\OccMap$ be a hash table that maps DNA sequences to sets of
		$k$-mer occurrences.}
	\STATE{Let $\OverlapSet$ be an empty set of overlaps.}
	\FOR{{\bf each} sequence $s \in \ReadSet$}
		\FOR{{\bf each} canonical $k$-mer $K \in r$}
			\STATE{Add the occurrence of $K$ to $\OccMap[K]$}
		\ENDFOR
	\ENDFOR
	\FOR{{\bf each} $(\SeedVar,\ \OccList) \in \OccMap$}
		\FOR{{\bf each} distinct pair of $k$-mer occurrences $\OccOne,
		\OccTwo \in \OccList$}
			\IF{the read ID of $\OccOne$ is greater than the read ID
			of $\OccTwo$}
				\STATE{Swap $\OccOne$ and $\OccTwo$}
			\ENDIF
			\IF{$\OccOne$ and $\OccTwo$ are both forward or both
			reverse-complement}
				\STATE{${\tt rc} \gets$ {\bf true}}
			\ELSE
				\STATE{${\tt rc} \gets$ {\bf false}}
			\ENDIF
			\STATE{$f \gets$ the read containing $\OccOne$}
			\STATE{$g \gets$ the read containing $\OccTwo$}
			\STATE{$\PosOne \gets$ the position within $f$ of $\OccOne$}
			\STATE{$\PosOne \gets$ the position within $g$ of $\OccTwo$}
			\STATE{$\Len \gets k$}
			\IF{${\tt rc}$}
				\STATE{$g' \gets$ the reverse complement of $g$}
				\STATE{${\tt \LeftExtend} \gets$ the number of
				additional bp to the left of the seed that
				match, comparing $f$ with $g'$}
				\STATE{${\tt \RightExtend} \gets$ the number of
				additional bp to the right of the seed that
				match, comparing $f$ with $g'$}
				\STATE{$\PosTwo \gets \PosTwo - {\tt
				\RightExtend}$}
			\ELSE
				\STATE{${\tt \LeftExtend} \gets$ the number of
				additional bp to the left of the seed that
				match, comparing $f$ with $g$}
				\STATE{${\tt \RightExtend} \gets$ the number of
				additional bp to the right of the seed that
				match, comparing $f$ with $g$}
				\STATE{$\PosTwo \gets \PosTwo - {\tt \LeftExtend}$}
			\ENDIF
			\STATE{$\PosOne \gets \PosOne - {\tt \LeftExtend}$}
			\STATE{$\Len \gets \Len + {\tt \LeftExtend} + {\tt \RightExtend}$}
			\IF{$\Len < \minOverlapLen$}
				\STATE{\bf continue}
			\ENDIF
			\STATE{$\readOneBeg \gets \PosOne$}
			\STATE{$\readOneEnd \gets \PosOne + \Len - 1$}
			\STATE{$\readTwoBeg \gets \PosTwo$}
			\STATE{$\readTwoEnd \gets \PosTwo + \Len - 1$}
			\STATE{$\numExtremePoints \gets 0$}
			\IF{$\readOneBeg = 0$}
				\STATE{$\numExtremePoints \gets \numExtremePoints + 1$}
			\ENDIF
			\IF{$\readOneEnd = {\sc Length}(f) - 1$}
				\STATE{$\numExtremePoints \gets \numExtremePoints + 1$}
			\ENDIF
			\IF{$\readTwoBeg = 0$}
				\STATE{$\numExtremePoints \gets \numExtremePoints + 1$}
			\ENDIF
			\IF{$\readTwoEnd = {\sc Length}(g) - 1$}
				\STATE{$\numExtremePoints \gets \numExtremePoints + 1$}
			\ENDIF


			%\STATE{Maximally extend the occurrence of $\SeedVar$ at
			%$\OccOne$ and $\OccTwo$ outwards in both directions}
			%\STATE{${\tt pos1} \gets$ the beginning of the maximally
			%matched region on the read containing $\OccOne$}
			%\STATE{${\tt pos2} \gets$ the beginning of the maximally
			%matched region on the read containing $\OccTwo$}
			%\STATE{${\tt plen} \gets$ the length of the maximally
			%matched region on the read containing $\OccTwo$}
		\ENDFOR
	\ENDFOR
\end{algorithmic}
\end{algorithm}
\end{comment}


\section{Building the fragment string assembly graph}

\label{sec:build_graph}

\subsection{Overview}

\label{subsec:graph_overview}

After overlaps have been computed from the reads, the next step is to construct
a graph that models how the reads can be assembled when the overlaps are used as
evidence.  To do this, define a graph where each vertex corresponds to a
read
%\footnote{Actually, more than one read may map to the same vertex, as explained
%in \Subsection{subsec:removing_contained_reads}.}
and each edge
corresponds to an overlap.  Two vertices are connected by an edge if and only if
the corresponding reads share an overlap.  In addition, each edge is labeled
with an appropriate DNA sequence, the details of which will be explained later.

It needs to be decided whether each edge will be directed, undirected, or
something else.  To decide this, we need to consider exactly what each edge
needs to represent.  Consider three reads $f$, $g$, and $h$, that overlap as
follows:

\begin{center}
	\begin{tikzpicture}[>=\ReadArrowType]
		\draw[->,style=very thick] (0,   0.6) node[anchor=east] {f} -- (3.0, 0.6);
		\draw[->,style=very thick] (1.0, 0.3) node[anchor=east] {g} -- (4.0, 0.3);
		\draw[<-,style=very thick] (2.0, 0.0) node[anchor=east] {h} -- (5.0, 0.0);
	\end{tikzpicture}
\end{center}

There are 3 overlaps, so there will be 3 edges--- one between $f$ and $g$, one
between $g$ and $h$, and one between $f$ and $h$.  As shown, the reads can be
assembled together consistently when used in the order $f,\ g,\ h$; therefore, it
must be possible to walk $f \to g \to h$ in the graph to model this assembly.
In addition, these reads could actually spell out the reverse-complement
sequence instead:

\begin{center}
	\begin{tikzpicture}[>=\ReadArrowType]
		\draw[->,style=very thick] (0,   0.0) node[anchor=east] {h} -- (3.0, 0.0);
		\draw[<-,style=very thick] (1.0, 0.3) node[anchor=east] {g} -- (4.0, 0.3);
		\draw[<-,style=very thick] (2.0, 0.6) node[anchor=east] {f} -- (5.0, 0.6);
	\end{tikzpicture}
\end{center}

Therefore, the walk $h \to g \to f$ must be allowed.  Furthermore, read $f$
directly overlaps with read $h$, so it must also be possible to walk directly $f
\to h$ or $h \to f$.

We might consider a directed graph as shown in
\Subfigure{subfig:possible_directed}, but this does not work because the graph
does not allow the reverse-complement walks such as $h \to g \to f$.

\begin{figure}
	\begin{center}
		\begin{subfigure}{0.32\textwidth}
			\begin{tikzpicture}[>=triangle 45]
				\tikzstyle{every node} = [circle,fill=\nodecolor,draw=black];
				\node (f) at (0, 0) {f};
				\node (g) at (1.7, 0) {g};
				\node (h) at (3.4, 0) {h};
				\draw[->,style=very thick] (f) edge (g);
				\draw[->,style=very thick] (g) edge (h);
				\draw[->,style=very thick,bend left] (f) edge (h);
			\end{tikzpicture}
			\caption{A possible directed \\representation of the \\string graph}
			\label{subfig:possible_directed}
		\end{subfigure}
		\begin{subfigure}{0.32\textwidth}
			\begin{tikzpicture}[>=triangle 45]
				\tikzstyle{every node} = [circle,fill=\nodecolor,draw=black];
				\node (f) at (0, 0) {f};
				\node (g) at (1.7, 0) {g};
				\node (h) at (3.4, 0) {h};
				\draw[-,style=very thick] (f) edge (g);
				\draw[-,style=very thick] (g) edge (h);
				\draw[-,style=very thick,bend left] (f) edge (h);
			\end{tikzpicture}
			\caption{A possible undirected \\representation of the \\string graph}
			\label{subfig:possible_undirected}
		\end{subfigure}
		\begin{subfigure}{0.32\textwidth}
			\begin{tikzpicture}[>=triangle 45]
				\tikzstyle{every node} = [circle,fill=\nodecolor,draw=black];
				\node (f) at (0, 0) {f};
				\node (g) at (1.7, 0) {g};
				\node (h) at (3.4, 0) {h};
				\draw[>->,style=very thick] (f) edge (g);
				\draw[>-<,style=very thick] (g) edge (h);
				\draw[>-<,style=very thick,bend left] (f) edge (h);
			\end{tikzpicture}
			\caption{The bidirected \\representation of the \\string graph}
			\label{subfig:possible_bidirected}
		\end{subfigure}
		\caption{Three possibilities for constructing the string graph.  The
		bidirected construction works the best in terms of modeling the
		underlying problem.}
	\end{center}
\end{figure}

Similarly, we might consider an undirected graph as shown in
\Subfigure{subfig:possible_undirected}, but this does not work because
the graph fails to disallow walks such as $g \to h \to f$ that correspond to
assemblies that are not supported by the underlying reads.

The fundamental problem with using the directed graph is that at this stage in
the assembly, we don't know in absolute terms which strand a given read is from.
Given two reads that overlap, we can say if they are probably from the same
strand or probably from opposite strands, but we cannot say {\em in absolute
terms} which strand a given read is from.  Therefore, we must allow each read to
be used in either the forward or reverse-complement direction.  This implies
that it needs to be possible to traverse each edge in either direction, since
flipping the order of the reads in an overlap, in effect, implies that they are
reverse-complemented.  The undirected graph satisfies these requirements, but it
fails in another way: it has no guarantee that a given read is used in a
consistent way at a location within any single assembly.

The solution to all these problems is to use a new type of graph called a
\KeyTerm{bidirected graph}, shown in \Subfigure{subfig:possible_bidirected}.

\subsection{Bidirected graphs}

A \KeyTerm{bidirected graph} is a graph where a directed head is attached to both
ends of each edge.

There are 3 (or 4, ignoring symmetry) types of \KeyTerm{bidirected edges}.  They
follow directly from the different types of overlaps, as shown in
\Figure{fig:overlap_mapping}.

\begin{figure}
	\begin{center}
		\begin{tabular}{p{1cm}cccc}
			{\footnotesize Overlap} &
			\begin{tikzpicture}[scale=0.6,>=\ReadArrowType]
					\draw[->,style=thick] (2,0) -- (0,0);
					\draw[->,style=thick] (1,0.3) -- (3,0.3);
			\end{tikzpicture}
			&
			\begin{tikzpicture}[scale=0.6,>=\ReadArrowType]
					\draw[->,style=thick] (0,0) -- (2,0);
					\draw[->,style=thick] (3,0.3) -- (1,0.3);
			\end{tikzpicture}
			&
			\begin{tikzpicture}[scale=0.6,>=\ReadArrowType]
					\draw[->,style=thick] (0,0) -- (2,0);
					\draw[->,style=thick] (1,0.3) -- (3,0.3);
			\end{tikzpicture}
			&
			\begin{tikzpicture}[scale=0.6,>=\ReadArrowType]
					\draw[->,style=thick] (2,0) -- (0,0);
					\draw[->,style=thick] (3,0.3) -- (1,0.3);
			\end{tikzpicture}
			\\
			&$\downarrow$ & $\downarrow$& $\downarrow$& $\downarrow$ \\
			{\footnotesize Bidirected edge} &
			\begin{tikzpicture}[scale=0.6,>=triangle 45]
					\draw[<->,style=thick] (0,0) -- (2,0);
			\end{tikzpicture}
			&
			\begin{tikzpicture}[scale=0.6,>=triangle 45]
					\draw[>-<,style=thick] (0,0) -- (2,0);
			\end{tikzpicture}
			&
			\begin{tikzpicture}[scale=0.6,>=triangle 45]
					\draw[>->,style=thick] (0,0) -- (2,0);
			\end{tikzpicture}
			&
			\begin{tikzpicture}[scale=0.6,>=triangle 45]
					\draw[<-<,style=thick] (0,0) -- (2,0);
			\end{tikzpicture}
		\end{tabular}
	\end{center}
	\caption{Mapping from the types of overlaps to the types of bidirected edges.}
	\label{fig:overlap_mapping}
\end{figure}

The \KeyTerm{in-degree} of a vertex $v$ in a bidirected graph is the number of
heads adjacent to $v$ that point inwards (towards $v$), while the
\KeyTerm{out-degree} of $v$ is the number of heads adjacent to $v$ that point
outwards (away from $v$).  A bidirected graph $G$ is \KeyTerm{balanced} if and
only if for every vertex in $G$ the in-degree is equal to the out-degree.

A \KeyTerm{walk} in a bidirected graph $G$ is a continuous sequence of edges in
$G$ such that if any vertex $v$ is entered through a head inwards, it is exited
through a head outwards (unless it is the end of the path), and vice versa.  An
equivalent formulation is that if we consider a possible walk in a bidirected
graph, such as the possible walk $1 \to 2 \to 3 \to 4$ in the graph shown in
\Figure{fig:bidiwalk_example}, in order to check whether the walk is valid or
not, we must consider every vertex in the possible walk except for the first and
last vertices.  For each such vertex, we need to verify that each time that
vertex is passed through as part of a walk, the arrow heads adjacent to that
vertex that are used in the relevant part of the walk are pointed in the same
direction {\em relative to the walk}. If there are no such pairs of heads that
point towards each other or point away from each other, the walk is valid.  The
circles in \Figure{fig:bidiwalk_example} show the two pairs of heads that need
to be checked for the possible walk $1 \to 2 \to 3 \to 4$.

Note that this definition is symmetric, which implies that the reverse of a walk
in a bidirected graph is also a valid walk (e.g. the walk $4 \to 3 \to 2 \to 1$
in \Figure{fig:bidiwalk_example}).  A bidirected edge may be traversed in either
direction, possibly even during the same walk.

\begin{figure}
	\begin{center} {\small
		\begin{tikzpicture}[>=triangle 45]
			\tikzstyle{every node} = [circle,fill=\nodecolor,draw=black];
			\node (1) at (0.00, 0) {1};
			\node (2) at (2.00, 0) {2};
			\node (3) at (4.00, 0) {3};
			\node (4) at (6.00, 0) {4};
			\draw[<->,very thick] (1) edge (2);
			\draw[>-<,very thick] (2) edge (3);
			\draw[<-<,very thick] (3) edge (4);
			\draw[color=black!70] (2.00, 0) circle (0.8);
			\draw[color=black!70] (4.00, 0) circle (0.8);
		\end{tikzpicture}
	} \end{center}
	\caption{$1 \to 2 \to 3 \to 4$ and $4 \to 3 \to 2 \to 1$ are both valid
	walks in the bidirected graph above.  (Check circled pairs of heads to
	verify this.)}
	\label{fig:bidiwalk_example}
\end{figure}

A \KeyTerm{cycle} in a bidirected graph is a walk that begins and ends at the
same vertex in such a way that it would be a valid to trace the walk again when
the starting vertex is reached at the end of the walk.

A bidirected graph is \KeyTerm{connected} if and only if  the undirected graph
produced by replacing all bidirected edges with undirected edges is connected
(as defined for undirected graphs).  A bidirected graph is \KeyTerm{strongly
connected} if and only if it is connected and for every edge there is a cycle
containing it\cite{Medvedev2009}.

The concept of a walk in a bidirected graph maps quite nicely onto the genome
assembly problem because a walk through the bidirected string graph constructed
from a set of reads and their overlaps models a way in which the reads can be
assembled together consistently\cite{Myers2005}.  In such a walk, each read may
be used in either forward or reverse-complement orientation, depending on the
direction, relative to the walk, of the adjacent arrow heads when the
corresponding vertex is passed through.

For example, consider the walk $1 \to 2 \to 3 \to 4$ in
\Figure{fig:bidigraph_mapping}.  When the walk passes through vertex 1, the
adjacent arrow head is pointed opposite the direction of the walk.  This implies
that the corresponding read is used in reverse-complement orientation.  When the
walk passes through vertex 2, the adjacent arrow heads are pointed in the
direction of the walk, which implies that the corresponding read is used in
forward orientation.  Finally, when the walk passes through vertices 3 and 4,
the adjacent arrow heads are pointed opposite the direction of the walk, which
implies that the corresponding reads are used in reverse-complement orientation.
Note that $4 \to 3 \to 2 \to 1$ is also a valid walk, which represents the way
in which the four reads could also assemble the other strand of the DNA
molecule.

\begin{figure}
	\begin{center}
		{\small
		\begin{tikzpicture}[>=triangle 45]
			\tikzstyle{every node} = [circle,fill=\nodecolor,draw=black];
			\node (1) at (0.00, 0) {1};
			\node (2) at (2.0, 0) {2};
			\node (3) at (4.0, 0) {3};
			\node (4) at (6.0, 0) {4};
			\draw[<->,very thick] (1) edge (2);
			\draw[>-<,very thick] (2) edge (3);
			\draw[<-<,very thick] (3) edge (4);
		\end{tikzpicture} }

		\vspace{2.5mm}

		\begin{tikzpicture}[>=\ReadArrowType]
				\draw[<-,style=very thick] (0.0, 0.0) -- (2.6, 0.0);
				\draw[->,style=very thick] (1.6, -0.3) -- (4.2, -0.3);
				\draw[<-,style=very thick] (3.2, -0.6) -- (5.8, -0.6);
				\draw[<-,style=very thick] (4.8, -0.9) -- (7.4, -0.9);
				\draw (-0.3, 0.0) node {1.};
				\draw (-0.3, -0.3) node {2.};
				\draw (-0.3, -0.6) node {3.};
				\draw (-0.3, -0.9) node {4.};
		\end{tikzpicture}
	\end{center}
	\caption{A bidirected graph and the implied assembly of the
	corresponding reads}
	\label{fig:bidigraph_mapping}
\end{figure}

Earlier, a crucial point was quickly skipped over.  Each edge is supposed to be
labeled with a DNA sequence, as we are building a bidirected {\em string} graph.
However, we actually need to label each edge with two DNA sequences: one for
each direction in which the edge can be traversed.  To see this, we need to
consider exactly what it means to walk between vertices in the bidirected graph.

Consider the the string graph fragment shown in
\Subfigure{subfig:bidiedge_interp_a}.  When we walk $f \to g$, both $f$ and $g$
are used in forward orientation, as indicated by the directions of the adjacent
arrow heads.  But what this really means is that we are walking from the {\em
end} of read $f$ to the {\em end} of read $g$.  In other words, traversing the
edge in that direction is associated with the addition of the sequence after the
overlapped region in $g$, up to the end of the $g$.

If we instead walk $g \to f$, both $g$ and $f$ are used reverse-complement
orientation by walking from the {\em beginning} of read $g$ to the {\em
beginning} of read $f$.  In other words, traversing the edge in that direction
is associated with the addition of the sequence before the overlapped region in
$f$, up to the beginning of $f$, and this sequence must be reverse-complemented
because it is being used opposite its original direction.

These interpretations can be generalized to the other two types of bidirected
edges, and this is described in slightly more detail in \cite{Myers2005}.
Furthermore, these interpretations imply that the actual sequence spelled out by
a walk in the bidirected graph may include implied (non-labeled) sequence at the
start (if we start at the end of a read) and/or the end (if we end at the
beginning of a read) of the walk.

\begin{figure}
	\begin{center}
		\begin{subfigure}[b]{0.48\textwidth}
			\begin{tikzpicture}[>=triangle 45,scale=1.5]
				\node[circle,fill=\nodecolor,draw=black] (f) at (0, 0) {f};
				\node[circle,fill=\nodecolor,draw=black] (g) at (2.0, 0) {g};
				\draw[>->,style=very thick] (f) edge (g);
				\draw (1.00, 0.1) node[anchor=south] {\small \tt TTAGAAGTA};
				\draw (1.00, -0.1) node[anchor=north] {
						\rotatebox{180}{\small \tt
						TGTGTAATC}};
				\draw[->] (0.5, 0.5) ..
					controls (0.7, 0.7) and (1.3, 0.7) ..
					(1.5, 0.5);
				\draw[->] (1.5, -0.5) ..
					controls (1.3, -0.7) and (0.7, -0.7) ..
					(0.5, -0.5);
			\end{tikzpicture}
			\caption{A bidirected string graph fragment}
			\label{subfig:bidiedge_interp_a}
		\end{subfigure}
		\begin{subfigure}[b]{0.48\textwidth}
			\begin{tikzpicture}[>=\ReadArrowType,scale=0.8]
				\draw[->,very thick] (-0.2, 0) node[anchor=east] {$f.B$}
						-> (4, 0) node[anchor=west] {$f.E$};
				\draw[->,very thick] (2.09, -0.9) node[anchor=east] {$g.B$}
						-> (6.29, -0.9) node[anchor=west] {$g.E$};

				\draw (-0.2, -0.1) node[anchor=south west]
					{\hspace*{-1.5mm}{\small \tt
						%GATTACACAGTGTAGTT
						GATTACACA\hspace*{1.5mm}$a_1 \dots a_n$
					}};

				\draw (-0.2, 0.1) node[anchor=north west]
					{\hspace*{-2.6mm}
						\rotatebox{180}{{\small \tt TGTGTAATC}}};

				\draw (2.09, -1.0) node[anchor=south west]
					{\hspace*{-1.4mm}{\small \tt
						%GTGTAGTTTTAGAAGTA
						\hspace*{0.1cm}$a_1 \dots a_n$\hspace*{0.25cm}TTAGAAGTA
					}};

				\draw (2.09, -0.9) node[anchor=north west]
					{\hspace*{12.88mm}
						\rotatebox{180}{{\small \tt TACTTCTAA}}};

				\draw (2.09, -1.4) node[anchor=north] {$o.g_{begin}$}
						-- (2.09, 0.6) node[anchor=south] {$o.f_{begin}$};
				\draw (3.99, -1.4) node[anchor=north] {$o.g_{end}$}
						-- (3.99, 0.6) node[anchor=south] {$o.f_{end}$};
			\end{tikzpicture}
			\caption{The corresponding overlap (labeled)}
			\label{subfig:bidiedge_interp_b}
		\end{subfigure}
	\end{center}

	\begin{subfigure}{1.00\textwidth}
		\begin{center}
			\begin{tikzpicture}[>=triangle 45,scale=1.5]
				\node[circle,fill=\nodecolor,draw=black] (fE) at (0, 0) {f.E};
				\node[circle,fill=\nodecolor,draw=black] (gE) at (2.5, 0) {g.E};

				\node[circle,fill=\nodecolor,draw=black] (fB) at (0, -1) {f.B};
				\node[circle,fill=\nodecolor,draw=black] (gB) at (2.5, -1) {g.B};

				\draw[->,style=very thick] (fE) edge (gE);
				\draw[->,style=very thick] (gB) edge (fB);
				\draw (1.2, 0.01) node[anchor=south] {\small \tt TTAGAAGTA};
				\draw (1.2, -1.01) node[anchor=north] {
						\rotatebox{180}{\small \tt
						TGTGTAATC}};
			\end{tikzpicture}
		\end{center}
		\caption{The corresponding directed string graph fragment}
		\label{subfig:bidiedge_interp_c}
	\end{subfigure}

	\vspace{1.0cm}

	\begin{subfigure}{1.00\textwidth}
		\begin{center}
			\begin{tabular}{c|c}
				walk & interpretation \\ \hline
				$f \to g$ & $f.E \to g.E$ with sequence $g[o.g_{end} + 1 \dots ${\tt
				length}$(g)]$ \\
				$g \to f$ & $g.B \to f.B$ with sequence $f[o.g_{begin} - 1 \dots 0]$ \\
			\end{tabular}
		\end{center}
		\caption{Interpretation of each walk on the bidirected graph fragment}
	\end{subfigure}
	\caption{Full interpretation of an edge in a bidirected string graph}
	\label{fig:bidiedge_interp}
\end{figure}

\subsection{An equivalent directed graph model}

\label{subsec:directed}

In \Subsection{subsec:graph_overview}, the possibility of using a directed graph
to model the assembly of the reads was rejected because it did not take into
account the double-strandedness of DNA.  However, \Figure{fig:bidiedge_interp}
suggests an alternate construction of the graph that does indeed use directed
edges.  Instead of having each vertex be a read, have each vertex be an end of a
read.  The advantage to this approach is that the problem can be expressed using
a directed graph instead a bidirected graph, which can be helpful for the
implementation.  The disadvantage is that there are two completely separate
vertices for each read.

\subsection{Removing contained reads}

\label{subsec:removing_contained_reads}

Earlier, the definition of a \KeyTerm{contained read} was provided.  Contained
reads need not be included in the graph because there will always be a walk that
spells the sequence of each contained read.
%In other words, contained reads
%provide redundant information because the sequence of any given contained read
%is already spelled out by an uncontained read.

Therefore, prior to mapping the reads to vertices and overlaps to edges, we can
examine the overlaps to identify contained reads, then include in the initial
construction of the bidirected string graph neither the contained reads nor any
overlaps involving a contained read.

This implies that a vertex in the bidirected string graph may actually
correspond to more than one read, which makes it meaningful to include a vertex
more than one time in a walk in the event of a genomic repeat.

The contained reads cannot be completely discarded because they are needed for a
later step (see \Subsection{subsec:mapping_contained_reads}).

\subsection{Implementation of assembly graph construction}

As described in \Subsection{subsec:removing_contained_reads}, before the
assembly graph is even built, contained reads need to be removed.  This is
implemented by the program \ProgramName{remove-contained-reads}.  It takes as
input two files: the set of reads and the set of overlaps that were computed
from them, and produces as output three files: the set of uncontained reads, the
set of overlaps excluding those that involve contained reads, and an array that
maps from the original read indices to the new read indices.

Building the graph is implemented by either the program
\ProgramName{build-bidirected-string-graph} or the program
\ProgramName{build-directed-string-graph}, the latter of which builds the
directed equivalent to the bidirected graph described in
\Subsection{subsec:directed}.  Both programs take as input two files: the set of
uncontained reads and their overlaps, and produce as output the bidirected or
directed graph, serialized to a file.
\ProgramName{build-bidirected-string-graph} will add one vertex for each
uncontained read and a bidirected edge for each overlap, while
\ProgramName{build-directed-string-graph} will add two vertices for each
uncontained read and two directed edges for each overlap.

The string graphs are stored in a binary format.  An additional program,
\ProgramName{print-string-graph}, was implemented that can print a string graph
in plain-text format, print a string graph in the DOT language for input to the
graph-drawing software {\it GraphViz}\cite{GraphVizPublication}, or print other
information about a string graph.

Furthermore, programs \ProgramName{bidigraph-to-digraph} and
\ProgramName{digraph-to-bidigraph} were implemented to convert between the
bidirected and directed representations of the string graph.

A program \ProgramName{extract-edge-seqs} was implemented to extract the
sequences that the edges are labeled with, as this can be done to produce a
preliminary assembly (especially after the graph simplifications described in
\Section{sec:simplify}).

\section{Simplifying the assembly graph}

\label{sec:simplify}

\subsection{Transitive reduction}

Before trying to find walks through the string graph, it is helpful to
simplify the graph as much as possible.  Very commonly, given three adjacent
reads $f$, $g$, and $h$, $f$ will overlap $h$ as well as $g$.  This is redundant
because we can, equivalently, walk $f \to g \to h$ rather than directly walking
$f \to h$.  \Figure{fig:transitive} shows an example of this.

\begin{figure}
	\begin{center}
		\begin{tikzpicture}
			\draw[->,style=very thick] (0,0) node[anchor=east] {f} -- (2,0);
			\draw[->,style=very thick] (0.6,0.25) node[anchor=east] {g} -- (2.6,0.25);
			\draw[->,style=very thick] (1.2,0.5) node[anchor=east] {h} -- (3.2,0.5);
		\end{tikzpicture}
		\begin{tikzpicture}[>=triangle 45]
			\tikzstyle{every node} = [circle,fill=\nodecolor,draw=black];
			\node (f) at (0, 0) {f};
			\node (g) at (1.7, 0) {g};
			\node (h) at (3.4, 0) {h};
			\draw[>->,style=very thick] (f) edge (g);
			\draw[>->,style=very thick] (g) edge (h);
			\draw[>->,style=very thick,bend left] (f) edge (h);
		\end{tikzpicture}
	\end{center}
	\caption{Three overlapping reads $f$, $g$, and $h$, and the corresponding
	bidirected graph.  The edge between $f$ and $h$ is transitive and is removed
	by transitive reduction.}
	\label{fig:transitive}
\end{figure}

Walks visiting more vertices are preferred because they are supported by more
reads and the overlaps tend to be longer.  So, we would like to throw away
\BidirectedEdgeForward{$f$}{$h$}, which is a \KeyTerm{transitive edge}, but keep
\BidirectedEdgeForward{$f$}{$g$} and \BidirectedEdgeForward{$g$}{$h$}.

To remove these redundant edges, \KeyTerm{transitive reduction} is performed on
the bidirected string graph.

\Algorithm{alg:transitive_reduction} provides pseudocode for a transitive
reduction algorithm similar to that described in \cite{Myers2005}.  Essentially,
the algorithm is to go through each vertex $v$ and examine vertices up to 2 edges
away from $v$ to identify all transitive edges leaving $v$.  These edges are
then marked for removal, and they are removed after all vertices in the graph
have been considered.  Some optimizations are possible; for example, the lengths
of the sequences the edges are labeled with can be taken into account to allow
terminating the search of $v$'s neighborhood before all possible walks of length
2 starting at $v$ have been considered.

Transitive reduction can be performed on either the bidirected or directed
representations of the string graph, although for simplicity
\Algorithm{alg:transitive_reduction} implies the directed representation.

\begin{algorithm}
	\caption{{\sc TransitiveReduction}($G$)}
	{\footnotesize
		\begin{algorithmic}
			\FOR{{\bf each} vertex $v \in G$}
				\STATE{Mark all neighbors of $v$ as {\tt INPLAY}}
				\STATE{Set {\tt longest} $\gets$ length of the longest edge leaving $v$}
				\FOR{{\bf each} edge $v \to w$ in order of length}
					\FOR{{\bf each} edge $w \to x$ in order of length}
						\IF{$x$ is not marked {\tt INPLAY}}
							\STATE{\bf continue}
						\ENDIF
						\IF{$len(v \to w) + len(w \to x) > $ {\tt longest}}
							\STATE{\bf break}
						\ENDIF
						\STATE{Mark $x$ as {\tt ELIMINATED}}
					\ENDFOR
				\ENDFOR
				\STATE{Mark as transitive all edges $v \to x$ where $x$ is marked {\tt ELIMINATED}}
			\ENDFOR
			\STATE{Eliminate all edges marked transitive}
		\end{algorithmic}
	}
	\label{alg:transitive_reduction}
\end{algorithm}

Transitive reduction on a string graph is implemented as the program
\ProgramName{transitive-reduction}.  It takes as input a file containing a
string graph and produces as output a file containing the transitively reduced
string graph.

\subsection{Collapsing unbranched paths}

After transitive reduction, a non-repetitive region of the genome typically will
be represented in the string graph by a chain of vertices that is part of a
valid walk and consists entirely of vertices with in-degree 1 and out-degree 1.
This is referred to as an \KeyTerm{unbranched path}, and it contains one or more
\KeyTerm{inner vertices}.  An unbranched path can be collapsed by removing the
inner vertices and replacing them by a single edge that covers the entire path.
This replacement edge is labeled with the concatenation of the sequences that
the original edges were labeled with.  In the bidirected case, this
concatenation must be done for both directions in which the unbranched path
might have been traversed.  \Figure{fig:collapse_unbranched_paths} shows an
example of how a short unbranched path can be collapsed.

\begin{figure}
	\begin{center}
		{\small
		\begin{tikzpicture}[>=triangle 45]
			\tikzstyle{every node} = [circle,fill=\nodecolor,draw=black];
			\node (1) at (0.0, -1) {1};
			\node (2) at (0.0, 1) {2};
			\node (3) at (1.5, 0) {3};
			\node[fill=\specialnodecolor] (4) at (3.25, 0) {4};
			\node (5) at (5.0, 0) {5};
			\node (6) at (6.5, 1) {6};
			\node (7) at (6.5, -1) {7};
			\draw[>->,very thick] (1) edge (3);
			\draw[>->,very thick] (2) edge (3);
			\draw[>->,very thick] (3) edge (4);
			\draw[>->,very thick] (4) edge (5);
			\draw[>->,very thick] (5) edge (6);
			\draw[>->,very thick] (5) edge (7);
		\end{tikzpicture}
		}

	becomes:

		{\small
		\begin{tikzpicture}[>=triangle 45]
			\tikzstyle{every node} = [circle,fill=\nodecolor,draw=black];
			\node (1) at (0.0, -1) {1};
			\node (2) at (0.0, 1) {2};
			\node (3) at (1.5, 0) {3};
			\node (5) at (3.25, 0) {5};
			\node (6) at (4.75, 1) {6};
			\node (7) at (4.75, -1) {7};
			\draw[>->,very thick] (1) edge (3);
			\draw[>->,very thick] (2) edge (3);
			\draw[>->,very thick] (3) edge (5);
			\draw[>->,very thick] (5) edge (6);
			\draw[>->,very thick] (5) edge (7);
		\end{tikzpicture}
		}
	\end{center}
	\caption{Vertex 4 is an inner vertex that is part of an unbranched path that
	can be collapsed.  Edge labels are not shown.}
	\label{fig:collapse_unbranched_paths}
\end{figure}

Collapsing unbranched paths is implemented as the program
\ProgramName{collapse-unbranched-paths}.  It takes as input a file containing a
string graph and produces as output a file containing the string graph with
unbranched paths collapsed.  The algorithm marks vertices with in-degree 1 and
out-degree 1 as inner, then iterates through every non-inner vertex to locate
adjacent inner vertices, which must be the ends of unbranched paths.  Each
unbranched path is then walked and collapsed.  Vertices are currently
re-numbered; so, for example, vertex 10 after collapsing unbranched paths does
not necessarily refer to the 10th read in the list of uncontained reads from
which the graph was constructed.

\section{Examples of assembly graph construction and simplification}

At this point, the assembler has been given a set of reads, has computed exact
overlaps from them, has removed contained reads and all overlaps involving them,
has built a bidirected string graph that models the ways in which the reads can
be assembled together when the overlaps are used as evidence, and has simplified
this graph through transitive reduction and collapsing unbranched paths.
Usually, the graph at this point will be much simpler than the original graph,
although it may still be very complicated, depending on the genome and the data.

\subsection{Random genome}

A completely random genome is unlikely to have repeats of significant length
compared to the minimum overlap length.  In this case, transitive reduction is
expected to leave the entire graph as a single unbranched path, provided the
original genome was a single, non-circular string and every base pair of it was
included in at least one read.  Then, collapsing unbranched paths will collapse
the entire bidirected graph into two vertices connected by a single edge.
Finding a walk through the edges of this graph is trivial and will produce an
assembly of the entire genome.  \Figure{fig:random_example} shows the bidirected
string graph that might result from such a genome and data.

If we still assume a genome with no repeats of length greater than the minimum
overlap length, but relax the assumption that the genome is a single,
non-circular string from which every base pair was included in a read, the graph
will instead reduce and collapse to a set of components.  Components
corresponding to non-circular sequence will contain two vertices with an edge
between, while components corresponding to circular sequence will contain one
vertex with an edge connecting it to itself (a loop).  In this case (and as will
be elaborated on later), finding a walk through the bidirected string graph must
be generalized to allow walking each component separately; but again for this
particular case of a random genome, each such walk is still trivial, and the
assembly will be optimal as long as the assembler does not decide to traverse
any of the loops more than one time (this will also be elaborated on more
later), since there are no repeats of substantial length in a hypothetical
random genome.

\begin{figure}
	\begin{center}
		\vspace{1cm}
		\begin{tikzpicture}
			{\small
			\begin{tikzpicture}[>=triangle 45]
				\node[circle,fill=\nodecolor,draw=black] (A) at (0.0, 0) {1};
				\node[circle,fill=\nodecolor,draw=black] (B) at (3.0, 0) {2};
				\draw[>->,very thick] (A) edge node[anchor=north] {4639100} (B);
			\end{tikzpicture} }
		\end{tikzpicture}
		\caption{
			Bidirected string graph for reads uniformly sampled from a 4.6 Mbp
			random genome after transitive reduction and unbranched path collapsing.  (Edge
			labeled with length of sequence, with the length being the same in both
			directions)}
		\label{fig:random_example}
	\end{center}
\end{figure}

\subsection{Real genome}

Real genomes are not random, and they contain far more repeats than would be
expected purely by chance.\footnote{Biologically, repeats can occur for a number
of reasons, such as gene duplications.} \Figure{fig:E_coli} shows an example of
the simplified bidirected string graph for reads sampled from a real genome.  It
is apparent that even when using perfect, fairly long reads that cover the
entire genome, the repeats in the genome cause branches to appear in the graph
when the repeats are too long to be resolved by the reads at this stage in the
assembly algorithm.

\begin{figure}
	\begin{center}
		\includegraphics[width=1.0\textwidth]{E_coli.pdf}
		\caption{Transitively-reduced, collapsed bidirected string graph for
		1000 bp perfect reads uniformly sampled every 100 bp from random strands
		of the non-circular version of the 4,639,675 bp genome of {\it E. coli}
		(a common bacterium) using a minimum overlap length of 250 bp.  This
		graph was produced by the code written for this project, but the actual
		drawing of the picture was done by {\it
		GraphViz}\cite{GraphVizPublication}.  The 46,387 reads
		that were provided as input to the assembler were generated by a Perl
		script.  The bottleneck of the algorithm up to this point is
		\ProgramName{compute-overlaps}, which took about 10 minutes and used a
		maximum of about 1 GiB of memory to find all 336,227 overlaps from these
		reads, seeding on 128-mers.  The running time and memory usage of
		\ProgramName{compute-overlaps} would need to improved further to handle
		larger genomes.}
		\label{fig:E_coli}
	\end{center}
\end{figure}

\subsection{Small step-by-step example}

This section walks through the construction and simplification of the bidirected
string graph on a very small example and provides a more detailed look at the
actual data.  The genome is 200 bp long and is given by the following plain-text
file:

%make -B SAMPLE_SIZE=200 READ_LEN=50 MIN_OVERLAP_LEN=15 out.reduced.mapped.bidigraph.pdf out.reduced.mapped.collapsed.bidigraph.pdf out.bidigraph.pdf COVERAGE=2.5 SEED=9 USE_PIRS=false

\begin{verbatim}
>random_genome
ACTCGAATTCCGAATAGATAGAAGTCTGCTGATAATATCGCGCCGGTTCTGATGCGCCTC
GGGGAACGTGGCGGGTAGAGCTATCGTGTCACTCTCTGTCAGTGGTCTGTGAAAATTGAT
CGCTACTGTCCCGGTGTAACCAGTCGACCCGCGGCAACTGCGAAGGGCCTCTCGCTCGCA
GTACTTCTCGGAGCTATCCC
\end{verbatim}

Note that in this file format, a continuous sequence can be split among multiple
lines, and a new sequence only begins after a line beginning with {\tt >} is
reached.

The reads are the following 10 reads that are 50bp each and sampled randomly
from either strand of the above genome:

\begin{verbatim}
>read_1
CAGAACCGGCGCGATATTATCAGCAGACTTCTATCTATTCGGAATTCGAG
>read_2
GCAGTTGCCGCGGGTCGACTGGTTACACCGGGACAGTAGCGATCAATTTT
>read_3
GCGGGTAGAGCTATCGTGTCACTCTCTGTCAGTGGTCTGTGAAAATTGAT
>read_4
AGTCTGCTGATAATATCGCGCCGGTTCTGATGCGCCTCGGGGAACGTGGC
>read_5
TTCGCAGTTGCCGCGGGTCGACTGGTTACACCGGGACAGTAGCGATCAAT
>read_6
TACACCGGGACAGTAGCGATCAATTTTCACAGACCACTGACAGAGAGTGA
>read_7
ACAGAGAGTGACACGATAGCTCTACCCGCCACGTTCCCCGAGGCGCATCA
>read_8
ACAGACCACTGACAGAGAGTGACACGATAGCTCTACCCGCCACGTTCCCC
>read_9
TAGCGATCAATTTTCACAGACCACTGACAGAGAGTGACACGATAGCTCTA
>read_10
CTATCGTGTCACTCTCTGTCAGTGGTCTGTGAAAATTGATCGCTACTGTC
\end{verbatim}

The location on the genome from which each of these 10 reads came is shown
below.  Note that by chance, 36 bp on the right end of the genome and 1 bp on
the left end of the genome are not included in any read:

\newcounter{readNumber}
\newcounter{readPos}
\newcounter{forwardReads}
\newcounter{rcReads}

\setcounter{forwardReads}{0}
\setcounter{rcReads}{1}

% ForwardRead{pos}{len}
\newcommand{\ForwardRead}[2]{
	\addtocounter{readNumber}{1}
	\addtocounter{forwardReads}{-1}
	\setcounter{readPos}{#1}
	\addtocounter{readPos}{#2}
	\draw[->, style=thick] (#1, \arabic{forwardReads}) node[anchor=east]
									{\arabic{readNumber}.} -- (\arabic{readPos},
									\arabic{forwardReads});
}

% RcRead{pos}{len}
\newcommand{\RcRead}[2]{
	\addtocounter{readNumber}{1}
	\addtocounter{rcReads}{1}
	\setcounter{readPos}{#1}
	\addtocounter{readPos}{#2}
	\draw[<-, style=thick] (#1, \arabic{rcReads}) node[anchor=east]
									{\arabic{readNumber}.} -- (\arabic{readPos},
									\arabic{rcReads});
}

\begin{center}
	\begin{tabular}{|ccc|}
	\hline
	{\bf Read number} & {\bf Position} & {\bf Reverse-complement?} \\ \hline
	1  & 1  & yes \\
	2  & 111  & yes \\
	3  & 70  & no \\
	4  & 22  & no \\
	5  & 114  & yes \\
	6  & 88  & yes \\
	7  & 49  & yes \\
	8  & 60  & yes \\
	9  & 75  & yes \\
	10  & 80  & no \\ \hline
	\end{tabular}

	\fbox{
	\begin{tikzpicture}[>=\ReadArrowType,x=0.56mm,y=3.5mm]
		\draw[<-, style=thick] (0, 1) node[anchor=east] {$G'$.} -- (200, 1);
		\draw[->, style=thick] (0, 0) node[anchor=east] {$G$.} -- (200, 0);

		\RcRead{1}{50}
		\RcRead{111}{50}
		\ForwardRead{70}{50}
		\ForwardRead{22}{50}
		\RcRead{114}{50}
		\RcRead{88}{50}
		\RcRead{49}{50}
		\RcRead{60}{50}
		\RcRead{75}{50}
		\ForwardRead{80}{50}
	\end{tikzpicture}
	}
\end{center}

\ProgramName{compute-overlaps} computes the following exact overlaps of minimum
length 15 bp among the above reads:

\begin{verbatim}
Overlap { Read 1: [0, 28], Read 4: [0, 28], rc = 1 }
Overlap { Read 2: [0, 46], Read 5: [3, 49], rc = 0 }
Overlap { Read 2: [23, 49], Read 6: [0, 26], rc = 0 }
Overlap { Read 2: [31, 49], Read 10: [31, 49], rc = 1 }
Overlap { Read 3: [18, 49], Read 6: [18, 49], rc = 1 }
Overlap { Read 3: [0, 28], Read 7: [0, 28], rc = 1 }
Overlap { Read 3: [0, 39], Read 8: [0, 39], rc = 1 }
Overlap { Read 3: [5, 49], Read 9: [5, 49], rc = 1 }
Overlap { Read 3: [10, 49], Read 10: [0, 39], rc = 0 }
Overlap { Read 4: [27, 49], Read 7: [27, 49], rc = 1 }
Overlap { Read 5: [26, 49], Read 6: [0, 23], rc = 0 }
Overlap { Read 5: [34, 49], Read 10: [34, 49], rc = 1 }
Overlap { Read 6: [28, 49], Read 8: [0, 21], rc = 0 }
Overlap { Read 6: [13, 49], Read 9: [0, 36], rc = 0 }
Overlap { Read 6: [8, 49], Read 10: [8, 49], rc = 1 }
Overlap { Read 7: [0, 38], Read 8: [11, 49], rc = 0 }
Overlap { Read 7: [0, 23], Read 9: [26, 49], rc = 0 }
Overlap { Read 7: [0, 18], Read 10: [0, 18], rc = 1 }
Overlap { Read 8: [0, 34], Read 9: [15, 49], rc = 0 }
Overlap { Read 8: [0, 29], Read 10: [0, 29], rc = 1 }
Overlap { Read 9: [0, 44], Read 10: [0, 44], rc = 1 }
\end{verbatim}

These overlaps are then used by \ProgramName{build-bidirected-string-graph} to
build the assembly graph.  Note that there are no contained reads in this
example, so there are as many vertices as original reads.  Also, in the
following graph drawings, each edge is labeled with the length of that edge's
sequence rather than the sequence itself.  Furthermore, although each edge
really contains a separate sequence for each direction, for this particular
example all the reads are the same length and only exact overlaps are
considered, which makes it so the two sequences of each edge are always the same
length.

\begin{center}
	\includegraphics[scale=0.7]{example_200bp.bidigraph-crop.pdf}	
\end{center}

The assembly graph then can be simplified by \ProgramName{transitive-reduction}:

\begin{center}
	\includegraphics[scale=0.8]{example_200bp.reduced.mapped.bidigraph-crop.pdf}	
\end{center}

Then, the assembly can be simplified further by
\ProgramName{collapse-unbranched-paths}:

\begin{center}
	\includegraphics[scale=0.8]{example_200bp.reduced.mapped.collapsed.bidigraph-crop.pdf}	
\end{center}

%\begin{figure}
	%\begin{center}
		%\begin{subfigure}{0.99\textwidth}
			%\begin{center}
				%\includegraphics[scale=0.5]{example.bidigraph-crop.pdf}	
				%\caption{Bidirected string graph built from 100 bp reads sampled
				%randomly at 5 $\times$ coverage from a 450 bp genome, using minimum 25
				%bp overlaps.  Note: edges are labeled with their lengths, not DNA
				%sequences.}
			%\end{center}
		%\end{subfigure}
		%\begin{subfigure}{0.99\textwidth}
			%\begin{center}
				%\includegraphics[scale=0.7]{example.reduced.mapped.bidigraph-crop.pdf}	
				%\caption{The bidirected string graph from the previous slide, after
				%transitive reduction.}
			%\end{center}
		%\end{subfigure}
		%\begin{subfigure}{0.99\textwidth}
			%\begin{center}
				%\includegraphics[scale=0.7]{example.reduced.mapped.collapsed.bidigraph-crop.pdf}	
				%\caption{The bidirected string graph from the previous slide, after
				%collapsing unbranched paths.}
			%\end{center}
		%\end{subfigure}
	%\end{center}
%\end{figure}

The result is the fully simplified bidirected string graph.  In this particular
example, the final graph is trivial and can be used to assemble the read-sampled
part of the original genome by walking $2 \to 1$.  Note that there is an implied
50bp before we start at the end of the read now labeled as 2 (which was
originally read 5), so the actual assembled sequence is $113 + 50 = 163$ bp
long.  The assembler should then generate the assembly:

\begin{verbatim}
>contig_1
CTCGAATTCCGAATAGATAGAAGTCTGCTGATAATATCGCGCCGGTTCTGATGCGCCTCG
GGGAACGTGGCGGGTAGAGCTATCGTGTCACTCTCTGTCAGTGGTCTGTGAAAATTGATC
GCTACTGTCCCGGTGTAACCAGTCGACCCGCGGCAACTGCGAA
\end{verbatim}

\section{Producing the final assembly}

\label{sec:final}

\subsection{Overview}

As \Figure{fig:E_coli} shows, the bidirected string graph may still be very
complicated even after transitive reduction and traversal.  In even worse
examples, the graph could easily have thousands of vertices and edges, and it
may not even be connected.  Therefore, we need to figure out how to walk through
the graph to produce the best assembly.

An \KeyTerm{Eulerian path in a bidirected graph} is a walk that traverses each
bidirected edge exactly one time in either direction.  Suppose we could find an
Eulerian path in the bidirected string graph.  Then this path would correspond
to an assembly that accounts for every overlap and therefore would be a valid
assembly of the original reads.  Furthermore, such a path may allow for vertices
to be used for than one time in the assembly to allow for genomic repeats, which
would not be true if we found a Hamiltonian path instead.\footnote{A Hamiltonian
path is also inappropriate here because unbranched paths have been collapsed
into single edges, which {\em must} be included in the assembly if the reads
corresponding to the inner vertices are to take part in the assembly.
Furthermore, keep in mind that there is not a one-for-one correspondence between
vertices and reads because contained reads were removed (see
\Subsection{subsec:removing_contained_reads}).}

However, there are multiple problems with this Eulerian path approach.  First,
the graph may not be Eulerian.  This could happen if the graph is not balanced.
This implies we really would need to solve the bidirected equivalent of the
Chinese Postman Problem instead.\footnote{The Chinese Postman problem on a
bidirected graph is formalized in \cite{Medvedev2009}.}  Even then, the graph
may not be fully connected, which would require that the final walk take the
form of a set of multiple discontinuous walks.  An equally severe problem is
that some overlaps may be spurious, meaning that the two overlapping reads do
not actually form a valid genomic sequence when combined.  Spurious overlaps can
be caused by genomic repeats.  Therefore, we need to allow for the possibility
that an edge in the bidirected graph can be omitted from the walk if it seems
like a good idea to do so.

The way these problems can be solved is to (1) place a lower bound and an upper
bound on the number of times each edge may be traversed, then (2) formulate and
solve a minimum-cost circulation problem that finds the minimum total traversal
count of edges in the graph in order for every vertex to be balanced (i.e. have
the same in-degree as out-degree), then (3) find a generalized Eulerian cycle
through the bidirected graph, traversing each edge the exact number of times
that was calculated in (2), but also allowing for the cycle to be logically
discontinuous by introducing a special vertex and special edges.

\subsection{Calculating the A-statistic}

\label{subsec:a_statistics}

We would like to use statistical properties of the original data to restrict the
number of times each bidirected edge may be traversed.  This can be done using a
calculation called the \KeyTerm{A-statistic}, or \KeyTerm{arrival-rate
statistic}, which is the logarithm of the probability that an edge represents
unique sequence rather than duplicate sequence \cite{Myers2005}.  The
A-statistic $A(e)$ of an edge $e$ in a bidirected string graph is:

\[ A(e) = \frac{n}{G} \Delta - \ln{2} \cdot {k} \]

where $n$ is the total number of reads, $G$ is the estimated genome length,
$\Delta$ is the average length of $e$'s two sequences in bp, and $k$
%is the number of reads that support that edge.  To more precise, $k$
is the number of inner vertices in the unbranched path corresponding to $e$
before the unbranched paths were collapsed \cite{Myers2005}.

Edges with sufficiently high A-statistic are very likely to be single-copy edges
and therefore should be traversed exactly one time.  The remaining edges may be
traversed any number of times (with the exact number being determined by the
minimum-cost circulation calculation), except for edges that originally were
associated with one or more inner vertices, in which case we require the edge be
traversed at least one time so that the reads corresponding to the inner
vertices are used in the reconstruction of the genome.  This is needed because
in the absence of foreign DNA, every read was presumably sampled from the
genome.

$G$, the estimated genome length, is actually unknown, so it must be estimated
first.  It can be estimated by producing a ``bootstrap'' genome length by adding
up the lengths of the sequences on every edge in both directions and dividing by
2, then calculating the A-statistics using this bootstrap genome length and
identifying edges that are probably single-copy.  The estimated genome length
can then be refined using just these single-copy edges before calculating the
final A-statistic on all the edges.  This algorithm is outlined in
\cite{Myers2005}.

The calculation of the A-statistic on each edge in the bidirected string graph,
including the genome length bootstrapping algorithm, is implemented by the
program {\tt calculate-A-statistics}.

\subsection{Mapping contained reads}

Because contained reads and their overlaps were removed before constructing the
assembly graph (see \Subsection{subsec:removing_contained_reads}), the
calculation of the A-statistic as described above is flawed because contained
reads need to be counted.  This is especially a problem for high copy-number
regions because those regions are likely to generate many contained reads.
Therefore, we need to map the contained reads into the graph before calculating
the A-statistics.

A contained read may easily be mapped to the vertex corresponding to a read that
contains it, but this is not sufficient because the A-statistic is calculated
over the edges, not the vertices.  Instead, we need to map each end of each
contained read to the edge, or in general the set of edges, in which the end
might be located if it were included as its own vertex.  Note that this mapping
makes more sense if we consider it in terms of the directed analogue of the
bidirected graph introduced in \Subsection{subsec:directed}.

The algorithm for doing this mapping is outlined in \cite{Myers2005} and was
implemented by the program \ProgramName{map-contained-reads}, which runs before
\ProgramName{collapse-unbranched-paths}.  Briefly, for each contained read $r$
the algorithm identifies the uncontained read $R$ that contains $r$ and has the
shortest distance from the end of $r$ to the end of $R$ (the shortest
\KeyTerm{overhang}).  This is done for each of the two directions.  The edges in
the graph starting at the vertex corresponding to that end of $R$ are then
walked backwards for the length of the overhang to find the set of edges $S$ to
which the relevant end of $r$ may map, and each edge in $S$ is marked as
containing $\frac{1}{|S|}$ extra inner vertices.  This mapping, therefore, makes
it possible to account for contained reads when calculating the A-statistic.

\label{subsec:mapping_contained_reads}

\subsection{Minimum-cost circulation}

\label{subsec:circulation}

Formally, a minimum-cost circulation problem on a directed graph takes as input
for each edge $e$ an lower bound $l(e) \ge 0$ and an upper bound $u(e) \ge 0$ on
flow and a cost per unit flow $v(e)$, and for each vertex $v$ a supply
(positive) or demand (negative) $b(v)$ for flow.  It produces as output a flow
$x(e)$ on each edge $e$ such that $\sum_e v(e)x(e)$ is minimized subject to
$x(e) \in [l(e), u(e)]$ and $\sum_{u \to v}x(u \to v) + b(v) = \sum_{v \to w}
x(v \to w)$ \cite{Myers2005}.  In the minimum-cost circulation problem, as
opposed to other network flow problems, no vertices are treated specially as
sources or sinks; instead, ingoing and outgoing flow must be balanced at every
vertex $v$, but only after taking into account the supply or demand $b(v)$ at
that vertex.

The A-statistic calculation on each edge $e$, as described in
\Subsection{subsec:a_statistics}, allows us to assign a lower bound $l(e)$ and
an upper bound $u(e)$ on the traversal count for that edge.  Note that $u(e)$
may be $\infty$.  We also have $b(v) = 0$ for all $v$, because the flow at every
vertex must be balanced; this corresponds to the desired walk entering each
vertex the same number of times that it is exited, making the graph as a whole
be balanced.  Furthermore, we have $v(e) = 1$ because no edges are considered
more costly to use than any other in this formulation.\footnote{Note that the
goal of this assembly algorithm is not to minimize the assembled genome length,
but rather to maximize the similarity of our assembled genome to the true
genome.  Therefore, there is no need to assign greater costs to edges that
represent longer DNA sequences (at least in this formulation of the problem),
because that would make it more costly to repeat a longer edge even if there is
strong evidence that edge corresponds to repeated sequence.}

%It produces as output a flow
%$x(e)$ on each edge $e$ such that $\sum_e v(e)x(e)$ is minimized subject to
%$x(e) \in [0, c(e)]$ and $\sum_{u \to v}x(u \to v) + b(v) = \sum_{v \to w} x(v
%\to w)$.\cite{Myers2005}.

%We can roughly map our problem onto this definition assigning $c(e) = 0$ when
%$e$ is definitely single-copy and $c(e) = \infty$ otherwise, $b(v)$ the sum
%of the lower bounds on the traversal counts of all bidirected edges incident to
%$v$ with an inward head minus the sum of the lower bounds on the traversal
%counts of all edges incident to $v$ with an outward head, and $v(e) = 1$.  The
%resulting traversal count $t(e)$ for a bidirected edge $e$ is then the lower
%bound on the traversal count for that edge plus $x(e)$, the traversal count
%assigned in the network flow calculation.  The traversal count $t(e)$ represents
%the total number of times the edge may be traversed in a given assembly,
%counting traversals in both directions.

There are still two serious problems with this circulation formulation that need
to be addressed.  First, we actually have a bidirected graph, not a directed
graph, so we need to calculate a \KeyTerm{bidirected flow}.\footnote{The fact
that this circulation problem actually needs to be formulated and solved on a
bidirected graph is addressed in \cite{Medvedev2009}, but not in
\cite{Myers2005}, even though the latter introduced the overall fragment string
graph algorithm.}
A bidirected flow is not the same as a directed flow because of the
presence of \BidirectedEdgeInnie and \BidirectedEdgeOutie edges, where the
magnitude of the flow on that edge is incoming to both both vertices (in
the case of a \BidirectedEdgeOutie edge) or outgoing from both vertices (in the case of
an \BidirectedEdgeInnie edge).  This does not imply that the edge itself is a
source or a sink, but rather than the flow is defined in a peculiar way that
makes sense on bidirected graphs.

Fortunately, there does exist a way to solve a bidirected flow problem by
mapping it to a directed flow problem by using the directed equivalent of the
bidirected graph, described in \Subsection{subsec:directed}.  However, the
calculated flow on a directed edge between, for example, two vertices $f.E \to
g.E$ is not guaranteed to be the same as the flow on $g.B \to f.B$, the edge
that corresponds to the other direction of the implied bidirected edge.  This
problem can be worked around by taking the average of the two counts and using
this as the flow on the bidirected edge.  This approximation is equivalent to
performing monotonization on the binet matrix that represents the linear program
reduction of bidirected flow; this produces a totally unimodular matrix that
represents a linear program that can be solved to find an integal flow that is
at worst a 2-approximation to the optimal integral flow on the bidirected
graph\cite{Medvedev2009}\cite{Hochbaum2004}.

The second problem with our circulation formulation is that the bidirected
string graph is not guaranteed to be connected, let alone strongly connected.
For example, there might be vertices that have in-degree 0 but have one or more
adjacent out-edges with nonzero lower bound on flow.  Such vertices may
represent the last read in a genomic region before a coverage gap or the end of
the sequence.  Our goal is to have such vertices be the endpoints of logical
walks through the bidirected graph.  To take this into account in the
formulation of the bidirected flow problem, we can introduce a special vertex
$s$ and unlabeled special edges between $s$ and every other vertex.  Each
special edge $e$ can have any amount of flow ($l(e) = 0,\ u(e) = \infty$), but
at great cost ($v(e) = X$, where $X$ is a very large number).  The addition of
these edges will make the graph strongly connected and possible to solve the
minimum-cost circulation problem to find a flow that corresponds to balancing
the in-degree and out-degree of every vertex by assigning a certain traversal
count $t(e)$ to each edge $e$.

For the implementation of this part of the algorithm, it should be possible to
make the above-mentioned modifications to the graph, then solve the bidirected
flow problem using the above-mentioned mapping to a directed flow problem.

\subsection{Generalized Eulerian cycle}

\label{subsec:eulerian}

Here, a \KeyTerm{generalized Eulerian cycle} means a cycle in a bidirected graph
$G$ that traverses each edge $e$ exactly $t(e)$ times, where $t(e)$ is the flow
on edge $e$ as calculated using the method in \Subsection{subsec:circulation}.
A generalized Eulerian cycle is guaranteed to exist in the bidirected graph at
this point because the graph was made strongly connected before solving the
minimum-cost circulation problem.  (A more thorough explanation of this
observation can be found in \cite{Medvedev2009}.)  The cycle corresponds to an
assembly of the genome that is consistent with the original reads, and it can be
decomposed into a set of logical walks by placing a logical breakpoint every
time the special vertex $s$ is passed through.  Each of these logical walks
represents the assembly of a separate contig.

It should be possible to find this generalized Eulerian cycle by adapting an
existing Eulerian path algorithm to work on a bidirected graph.

\section{Implementation}

The implementation of the fragment string graph algorithm that was done for this
project is a set of C++ programs that iteratively transform the data on-disk
into the final assembly.  Each program takes as input one or more files as well
as zero or more other command-line arguments and produces as output one or more
files.  Each file contains data such as a list of reads, a list of overlaps, or
a graph.  Internally to the assembler pipeline, data is stored in binary form.
\Figure{fig:impl_graph} shows how the data flows through the main stages of the
assembler.  The assembly pipeline is run using a Makefile that describes this
control flow.

The input to the assembler is one or more files in plain-text form that each
contain a list of reads.  The final output of the assembler will eventually be a
file in plain-text format that gives the list of assembled contigs.  However,
the final stages of the algorithm (Sections \ref{subsec:circulation} and
\ref{subsec:eulerian}) have not been implemented as of the end of the semester
of Fall 2012.

\begin{figure}
	\begin{center}
		\includegraphics[width=0.7\textwidth]{programs.pdf}
	\end{center}
	\caption{The flow of data through the assembly pipeline.  Each node is a
	program and each arrow represents the output of a program being used as
	input in another program.  Grayed-out programs have not yet been implemented
	as of December 10, 2012.}
	\label{fig:impl_graph}
\end{figure}

\section{Possible future work}

\begin{itemize}
\item Finish the minimum-cost circulation and generalized Eulerian path parts of
the algorithm so that the implementation is ``complete'' and can produce a
``final'' assembly.
\item Improve the performance of \ProgramName{compute-overlaps}.
\item Allow for sequencing errors by finding inexact overlaps and modifying other
stages of the algorithm, such as transitive reduction, to allow for the
possibility that overlaps are inexact.
\item Compensate for sequencing errors by attempting to correct them, either as
part of \ProgramName{compute-overlaps} or as a new stage of the algorithm.
\item Consider more recent publications that explore variations on this
algorithm, such as parallelizing the algorithm \cite{Jackson2008}, or using the
Burrows-Wheeler transform to efficiently construct the transitively-reduced
bidirected string graph directly from the original reads \cite{Simpson2010}.
\item Use mate-pair information to help resolve repeats and connect assembled
sequences even when they are separated by unknown sequence, possibly using ideas
from \cite{Medvedev2009}.
\end{itemize}

\addcontentsline{toc}{section}{References}
\bibliographystyle{plain}
\bibliography{refs}

\end{document}
